<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Jackie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Jackie">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jackie">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jackie">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-TCP报文头结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/18/TCP报文头结构/">TCP报文头结构</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/18/TCP报文头结构/" class="article-date">
  <time datetime="2017-08-17T18:16:16.000Z" itemprop="datePublished">2017-08-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-TCP-报文头结构"><a href="#1-TCP-报文头结构" class="headerlink" title="1.TCP 报文头结构"></a>1.TCP 报文头结构</h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708240001.jpg" alt=""></p>
<h2 id="2-报文头各个部分说明"><a href="#2-报文头各个部分说明" class="headerlink" title="2.报文头各个部分说明"></a>2.报文头各个部分说明</h2><h3 id="2-1-Source-Port和Destination-Port"><a href="#2-1-Source-Port和Destination-Port" class="headerlink" title="2.1.Source Port和Destination Port:"></a>2.1.Source Port和Destination Port:</h3><p>分别占用16位，表示源端口号和目的端口号;用于区别主机中的不同进程， 而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一 的确定一个TCP连接;</p>
<h3 id="2-2-Sequence-Number"><a href="#2-2-Sequence-Number" class="headerlink" title="2.2.Sequence Number:"></a>2.2.Sequence Number:</h3><p>用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据 字节在数据流中的序号;主要用来解决网络报乱序的问题;</p>
<h3 id="2-3-Acknowledgment-Number"><a href="#2-3-Acknowledgment-Number" class="headerlink" title="2.3.Acknowledgment Number:"></a>2.3.Acknowledgment Number:</h3><p>32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应 当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字 段才有效。主要用来解决不丢包的问题;</p>
<h3 id="2-4-Offset"><a href="#2-4-Offset" class="headerlink" title="2.4.Offset:"></a>2.4.Offset:</h3><p>给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit(最多能 表示15个32bit的的字，即4*15=60个字节的首部长度)，因此TCP最多有60字节的首部。然而，没有任选字段， 正常的长度是20字节;</p>
<h3 id="2-5-TCP-Flags"><a href="#2-5-TCP-Flags" class="headerlink" title="2.5.TCP Flags:"></a>2.5.TCP Flags:</h3><p>TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次 为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：</p>
<h3 id="2-6-URG："><a href="#2-6-URG：" class="headerlink" title="2.6.URG："></a>2.6.URG：</h3><p>此标志表示TCP包的紧急指针域(后面马上就要说到)有效，用来保证TCP连接不被中断，并且督促 中间层设备要尽快处理这些数据;</p>
<h3 id="2-7-ACK："><a href="#2-7-ACK：" class="headerlink" title="2.7.ACK："></a>2.7.ACK：</h3><p>此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中;有两个取值：0和1， 为1的时候表示应答域有效，反之为0;</p>
<h3 id="2-8-PSH："><a href="#2-8-PSH：" class="headerlink" title="2.8.PSH："></a>2.8.PSH：</h3><p>这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序， 而不是在缓冲区中排队;</p>
<h3 id="2-9-RST："><a href="#2-9-RST：" class="headerlink" title="2.9.RST："></a>2.9.RST：</h3><p>这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包;</p>
<h3 id="3-0-SYN："><a href="#3-0-SYN：" class="headerlink" title="3.0.SYN："></a>3.0.SYN：</h3><p>表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1， ACK=0;连接被响应的时候，SYN=1，ACK=1;这个标志的数据包经常被用来进行端口扫描。扫描者发送 一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口;但是由于这 种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全 的主机将会强制要求一个连接严格的进行TCP的三次握手;</p>
<h3 id="3-1-FIN："><a href="#3-1-FIN：" class="headerlink" title="3.1.FIN："></a>3.1.FIN：</h3><p>表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志 位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</p>
<h3 id="3-2-Window"><a href="#3-2-Window" class="headerlink" title="3.2.Window:"></a>3.2.Window:</h3><p>窗口大小，也就是有名的滑动窗口。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-蓝牙协议入门（四）应用层协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/08/蓝牙协议入门（四）应用层协议/">蓝牙协议入门（四）应用层协议</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/08/蓝牙协议入门（四）应用层协议/" class="article-date">
  <time datetime="2017-08-08T02:10:47.000Z" itemprop="datePublished">2017-08-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-irOBEX-红外对象交互协议"><a href="#1-irOBEX-红外对象交互协议" class="headerlink" title="1.irOBEX 红外对象交互协议"></a>1.irOBEX 红外对象交互协议</h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030001.png" alt=""></p>
<p><strong>irOBEX</strong>  红外对象交互协议，简称 <strong>OBEX</strong>，使高层协议同时运作在蓝牙和红外的无线链路之上。主要操作指令包括：</p>
<ul>
<li>连接操作</li>
<li>断开操作</li>
<li>Put 操作</li>
<li>Get 操作</li>
</ul>
<h3 id="1-1-连接操作"><a href="#1-1-连接操作" class="headerlink" title="1.1.连接操作"></a>1.1.连接操作</h3><p>连接操作的操作码为： 0x80。</p>
<table>
<thead>
<tr>
<th>字节0</th>
<th>字节1、2</th>
<th>字节3</th>
<th>字节4</th>
<th>字节5、6</th>
<th>字节7～n</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x80</td>
<td>连接请求分组长度</td>
<td>OBEX版本号</td>
<td>标志</td>
<td>客户端可接收最大的OBEX分组长度</td>
<td>可选头</td>
</tr>
</tbody>
</table>
<p>下面是一个连接操作的示例：</p>
<table>
<thead>
<tr>
<th>字节0</th>
<th>字节1、2</th>
<th>字节3</th>
<th>字节4</th>
<th>字节5、6</th>
<th>字节7～n</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x80 Connect命令</td>
<td>7</td>
<td>0x10</td>
<td>flags</td>
<td>65534</td>
<td>可选头</td>
</tr>
</tbody>
</table>
<h3 id="1-2-断开操作"><a href="#1-2-断开操作" class="headerlink" title="1.2.断开操作"></a>1.2.断开操作</h3><p>断开操作的操作码为：0x81。</p>
<h3 id="1-3-Put-操作"><a href="#1-3-Put-操作" class="headerlink" title="1.3.Put 操作"></a>1.3.Put 操作</h3><p>Put 操作的操作码为：0x02。</p>
<h3 id="1-4-Get-操作"><a href="#1-4-Get-操作" class="headerlink" title="1.4.Get 操作"></a>1.4.Get 操作</h3><p>Get 操作的操作码为：0x03。</p>
<h2 id="2-音频与电话控制协议"><a href="#2-音频与电话控制协议" class="headerlink" title="2.音频与电话控制协议"></a>2.音频与电话控制协议</h2><h3 id="2-1-协议架构"><a href="#2-1-协议架构" class="headerlink" title="2.1.协议架构"></a>2.1.协议架构</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030002.png" alt=""></p>
<p>蓝牙音频如上图协议栈所示：音频通过基带传输同步面向连接分组实现，没有以规范的形式给出，不是协议栈的一部分。<br><strong>TCS_Binary</strong> 是一种基于分组电话控制二进制编码指令集，位于 <strong>L2CAP</strong> 之上。实现蓝牙无绳电话、对讲机功能。<br><strong>RFCOMM</strong> 用于 <strong>AT</strong> 指令，拨号上网、蓝牙耳机、耳麦、传真通过 <strong>AT</strong> 发送指令控制。</p>
<h3 id="2-2-音频部分"><a href="#2-2-音频部分" class="headerlink" title="2.2.音频部分"></a>2.2.音频部分</h3><p><strong>64kbps</strong> 电信级语言质量音频流<br>​    <strong>CVSD  continuous variable slope delta</strong> 连续可变斜率增量。<br>​    <strong>PCM  pulse code modulation</strong> 。<br>​    <strong>PCM</strong> 存在斜率效应。<strong>CVSD</strong> 使用音节压缩算法，编码步长根据信号斜率变化自动调整，是现在比较好的编码方案，提高语言的抗干扰能力。</p>
<h3 id="2-3-电话控制部分"><a href="#2-3-电话控制部分" class="headerlink" title="2.3.电话控制部分"></a>2.3.电话控制部分</h3><p><strong>TCS-Binary</strong> 电话控制部分。</p>
<ul>
<li><p>电话呼叫</p>
<p>​呼叫控制、呼叫建立、呼叫拆除；</p>
</li>
<li><p>组管理</p>
<p>​访问权限请求、分布式配置、快速内部成员访问。</p>
</li>
</ul>
<h2 id="3-网络封装协议-BNEP"><a href="#3-网络封装协议-BNEP" class="headerlink" title="3.网络封装协议  BNEP"></a>3.网络封装协议  BNEP</h2><p><strong>BNEP</strong>（<strong>Bluetooth Network Encapsulation Protocol</strong>） 网络封装协议。为了使集成蓝牙技术的电脑、电话、<strong>PDA</strong>、家用电器等网络设备交换信息，需要在网络层统一数据分组。网络封装协议将来自不同网络的数据分组重新封装，通过 <strong>L2CAP</strong> 进行传输。<strong>BNEP</strong> 支持 <strong>Ipv4、Ipv6、IPX</strong> 。</p>
<h2 id="4-音视频分发协议AVDTP"><a href="#4-音视频分发协议AVDTP" class="headerlink" title="4.音视频分发协议AVDTP"></a>4.音视频分发协议AVDTP</h2><p><strong>AVDTP （Audio/Video Distribution Transport Protocol）</strong>音视频分发传输协议。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030004.png" alt=""></p>
<p><strong>AVDTP</strong> 信令列表:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信令标识符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVDTP_DISCOVER</td>
<td>0x01</td>
<td>发现设备中的流端点</td>
</tr>
<tr>
<td>AVDTP_GET_CAPABILITIES</td>
<td>0x02</td>
<td>获得流端点的信息能力</td>
</tr>
<tr>
<td>AVDTP_SET_CONFIGURATION</td>
<td>0x03</td>
<td>对SEP进行配置</td>
</tr>
<tr>
<td>AVDTP_GET_CONFIGURATION</td>
<td>0x04</td>
<td>获取SEP当前配置</td>
</tr>
<tr>
<td>AVDTP_RECONFIGURE</td>
<td>0x05</td>
<td>对SEP重新配置</td>
</tr>
<tr>
<td>AVDTP_OPEN</td>
<td>0x06</td>
<td>成功的配置SEP后，打开流</td>
</tr>
<tr>
<td>AVDTP_START</td>
<td>0x07</td>
<td>流被打开：用于开始形成流；流暂停时：用于重新形成流。</td>
</tr>
<tr>
<td>AVDTP_CLOSE</td>
<td>0x08</td>
<td>对SEP关闭</td>
</tr>
<tr>
<td>AVDTP_SUSPEND</td>
<td>0x09</td>
<td>请求SEP暂停</td>
</tr>
<tr>
<td>AVDTP_SECURITY_CONTROL</td>
<td>0x0A</td>
<td>设置设备内容保护、或者请求设备状况信息</td>
</tr>
<tr>
<td>AVDTP_ABORT</td>
<td>0x0B</td>
<td>中断正在建立或者传输的过程</td>
</tr>
<tr>
<td>AVDTP_GET_ALL_CAPABILITIES</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AVDTP_DELAYREPORT</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="5-音视频控制传输协议AVCTP"><a href="#5-音视频控制传输协议AVCTP" class="headerlink" title="5.音视频控制传输协议AVCTP"></a>5.<strong>音视频控制传输协议AVCTP</strong></h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030003.png" alt=""></p>
<p><strong>AVCTP</strong> 可以使音视频设备同时支持多个应用框架，每个应用框架定义了各自相应的消息格式与应用规则。</p>
<h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6.参考链接"></a>6.参考链接</h2><p> <a href="http://blog.csdn.net/xubin341719/article/details/38335533" target="_blank" rel="external">蓝牙核心技术概述（五）：蓝牙协议规范（irOBEX、BNEP、AVDTP、AVCTP）</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/蓝牙/">蓝牙</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-Redis常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/01/Redis常用命令/">Redis常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/01/Redis常用命令/" class="article-date">
  <time datetime="2017-08-01T08:12:47.000Z" itemprop="datePublished">2017-08-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h2><h3 id="1-1-SET-命令"><a href="#1-1-SET-命令" class="headerlink" title="1.1. SET 命令"></a>1.1. SET 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080001.png" alt=""></p>
<h3 id="1-2-GET-命令"><a href="#1-2-GET-命令" class="headerlink" title="1.2. GET 命令"></a>1.2. GET 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080002.png" alt=""></p>
<h3 id="1-3-GETSET-命令"><a href="#1-3-GETSET-命令" class="headerlink" title="1.3. GETSET 命令"></a>1.3. GETSET 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080003.png" alt=""></p>
<h3 id="1-4-INCR-自增命令"><a href="#1-4-INCR-自增命令" class="headerlink" title="1.4. INCR 自增命令"></a>1.4. INCR 自增命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080004.png" alt=""></p>
<h2 id="2-有序集合（Sorted-Set）"><a href="#2-有序集合（Sorted-Set）" class="headerlink" title="2.有序集合（Sorted Set）"></a>2.有序集合（Sorted Set）</h2><h3 id="2-1-ZADD-命令"><a href="#2-1-ZADD-命令" class="headerlink" title="2.1. ZADD 命令"></a>2.1. ZADD 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080005.png" alt=""></p>
<h3 id="2-2-ZCARD-数量统计命令"><a href="#2-2-ZCARD-数量统计命令" class="headerlink" title="2.2. ZCARD 数量统计命令"></a>2.2. ZCARD 数量统计命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080006.png" alt=""></p>
<h3 id="2-3-ZCOUNT-查找指定区间成员数命令"><a href="#2-3-ZCOUNT-查找指定区间成员数命令" class="headerlink" title="2.3. ZCOUNT 查找指定区间成员数命令"></a>2.3. ZCOUNT 查找指定区间成员数命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080007.png" alt=""></p>
<h3 id="2-4-ZRANK-返回查找值排名命令"><a href="#2-4-ZRANK-返回查找值排名命令" class="headerlink" title="2.4. ZRANK 返回查找值排名命令"></a>2.4. ZRANK 返回查找值排名命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080008.png" alt=""></p>
<h3 id="2-5-ZREM-移除元素命令"><a href="#2-5-ZREM-移除元素命令" class="headerlink" title="2.5. ZREM 移除元素命令"></a>2.5. ZREM 移除元素命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080009.png" alt=""></p>
<h3 id="2-6-ZUNIONSTORE-并集命令"><a href="#2-6-ZUNIONSTORE-并集命令" class="headerlink" title="2.6. ZUNIONSTORE 并集命令"></a>2.6. ZUNIONSTORE 并集命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080010.png" alt=""></p>
<h3 id="2-7-ZINTERSTORE-交集命令"><a href="#2-7-ZINTERSTORE-交集命令" class="headerlink" title="2.7. ZINTERSTORE 交集命令"></a>2.7. ZINTERSTORE 交集命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080011.png" alt=""></p>
<h3 id="2-8-ZRANGE-范围显示指令"><a href="#2-8-ZRANGE-范围显示指令" class="headerlink" title="2.8. ZRANGE 范围显示指令"></a>2.8. ZRANGE 范围显示指令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080011.png" alt=""></p>
<h2 id="3-哈希（HashSet）"><a href="#3-哈希（HashSet）" class="headerlink" title="3. 哈希（HashSet）"></a>3. 哈希（HashSet）</h2><h3 id="3-1-HSET-插入指令"><a href="#3-1-HSET-插入指令" class="headerlink" title="3.1. HSET 插入指令"></a>3.1. HSET 插入指令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080012.png" alt=""></p>
<h3 id="3-2-HGET-读取指令"><a href="#3-2-HGET-读取指令" class="headerlink" title="3.2. HGET 读取指令"></a>3.2. HGET 读取指令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080013.png" alt=""></p>
<h3 id="3-3-HGETALL-读取全部"><a href="#3-3-HGETALL-读取全部" class="headerlink" title="3.3. HGETALL 读取全部"></a>3.3. HGETALL 读取全部</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080014.png" alt=""></p>
<h3 id="3-4-HSETNX-如果不存在则赋值"><a href="#3-4-HSETNX-如果不存在则赋值" class="headerlink" title="3.4. HSETNX 如果不存在则赋值"></a>3.4. HSETNX 如果不存在则赋值</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080015.png" alt=""></p>
<h3 id="3-5-HDEL-删除"><a href="#3-5-HDEL-删除" class="headerlink" title="3.5. HDEL 删除"></a>3.5. HDEL 删除</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080016.png" alt=""></p>
<h2 id="4-列表（List）"><a href="#4-列表（List）" class="headerlink" title="4.列表（List）"></a>4.列表（List）</h2><h3 id="4-1-PUSH（插入元素，分为左-LPUSH-和右-RPUSH）"><a href="#4-1-PUSH（插入元素，分为左-LPUSH-和右-RPUSH）" class="headerlink" title="4.1. PUSH（插入元素，分为左 LPUSH 和右 RPUSH）"></a>4.1. PUSH（插入元素，分为左 LPUSH 和右 RPUSH）</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080017.png" alt=""></p>
<h3 id="4-2-LRANGE-输出某一段元素"><a href="#4-2-LRANGE-输出某一段元素" class="headerlink" title="4.2. LRANGE 输出某一段元素"></a>4.2. LRANGE 输出某一段元素</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080018.png" alt=""></p>
<h3 id="4-3-POP（分为-LPOP-和-RPOP）"><a href="#4-3-POP（分为-LPOP-和-RPOP）" class="headerlink" title="4.3. POP（分为 LPOP 和 RPOP）"></a>4.3. POP（分为 LPOP 和 RPOP）</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080019.png" alt=""></p>
<h3 id="4-4-LLEN-输出列表长度"><a href="#4-4-LLEN-输出列表长度" class="headerlink" title="4.4. LLEN 输出列表长度"></a>4.4. LLEN 输出列表长度</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080020.png" alt=""></p>
<h3 id="4-5-LINDEX-输出某位置元素"><a href="#4-5-LINDEX-输出某位置元素" class="headerlink" title="4.5. LINDEX 输出某位置元素"></a>4.5. LINDEX 输出某位置元素</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080021.png" alt=""></p>
<h2 id="5-集合"><a href="#5-集合" class="headerlink" title="5.集合"></a>5.集合</h2><h3 id="5-1-SADD-插入命令"><a href="#5-1-SADD-插入命令" class="headerlink" title="5.1. SADD 插入命令"></a>5.1. SADD 插入命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080022.png" alt=""></p>
<h3 id="5-2-SCARD-统计个数命令"><a href="#5-2-SCARD-统计个数命令" class="headerlink" title="5.2. SCARD 统计个数命令"></a>5.2. SCARD 统计个数命令</h3><p>​              <img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080023.png" alt=""></p>
<h3 id="5-3-SDIFFSTORE-差集并存储"><a href="#5-3-SDIFFSTORE-差集并存储" class="headerlink" title="5.3. SDIFFSTORE 差集并存储"></a>5.3. SDIFFSTORE 差集并存储</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080024.png" alt=""></p>
<h3 id="5-4-SUNION-并集（SUNIONSTORE-则存储）"><a href="#5-4-SUNION-并集（SUNIONSTORE-则存储）" class="headerlink" title="5.4. SUNION 并集（SUNIONSTORE 则存储）"></a>5.4. SUNION 并集（SUNIONSTORE 则存储）</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080025.png" alt=""></p>
<h3 id="5-5-SINTER-交集"><a href="#5-5-SINTER-交集" class="headerlink" title="5.5. SINTER 交集"></a>5.5. SINTER 交集</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080026.png" alt=""></p>
<h3 id="5-6-SPOP-随机弹出"><a href="#5-6-SPOP-随机弹出" class="headerlink" title="5.6. SPOP 随机弹出"></a>5.6. SPOP 随机弹出</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080027.png" alt=""></p>
<h3 id="5-7-SMEMBERS-显示所有元素"><a href="#5-7-SMEMBERS-显示所有元素" class="headerlink" title="5.7. SMEMBERS 显示所有元素"></a>5.7. SMEMBERS 显示所有元素</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080028.png" alt=""></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-java基础之垃圾回收器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/25/java基础之垃圾回收器/">Java基础之垃圾回收器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/07/25/java基础之垃圾回收器/" class="article-date">
  <time datetime="2017-07-25T10:38:00.000Z" itemprop="datePublished">2017-07-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h2><p><strong>Serial</strong> 收集器是单线程垃圾回收器，它仅能使用单个线程去进行垃圾回收的工作，而且在进行垃圾回收时需要 <strong>“Stop the World”</strong>。也就是说，在它工作的同时，其他线程必须暂停运行。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260001.png" alt=""></p>
<h2 id="2-Serial-Old-收集器"><a href="#2-Serial-Old-收集器" class="headerlink" title="2. Serial Old 收集器"></a>2. Serial Old 收集器</h2><p><strong>Serial</strong> 收集器的老年代版本。一种用途是在 <strong>JDK 1.5</strong> 以及之前的版本中与<strong>Parallel Scavenge</strong> 收集器搭配使用，另一种用途就是作为<strong>CMS</strong> 收集器的后备预案，在并发收集发生<strong>Concurrent Mode Failure</strong> 时使用。 </p>
<h2 id="3-ParNew-收集器"><a href="#3-ParNew-收集器" class="headerlink" title="3. ParNew 收集器"></a>3. ParNew 收集器</h2><p><strong>ParNew</strong> 收集器是 <strong>Serial</strong> 收集器的多线程版本。因为功能强大的老年代收集器 <strong>CMS</strong> 收集器无法与 <strong>Parallel Scavenge</strong> 收集器配合工作，因此 <strong>CMS</strong> 收集器常与 <strong>ParNew</strong> 收集器配合使用。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260002.png" alt=""></p>
<h2 id="4-Parallel-Scavenge-收集器"><a href="#4-Parallel-Scavenge-收集器" class="headerlink" title="4. Parallel Scavenge 收集器"></a>4. Parallel Scavenge 收集器</h2><p><strong>Parallel Scavenge</strong> 收集器的特点是它的关注点与其他收集器不同，<strong>CMS</strong> 等收集器的关注点<br>是尽可能地缩短垃圾收集时用户线程的停顿时间，而<strong>Parallel Scavenge</strong> 收集器的目标则是达到<br>一个可控制的吞吐量。 </p>
<h2 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h2><p><strong>Parallel Old</strong> 是 <strong>Parallel Scavenge</strong> 收集器的老年代版本，使用多线程和“标记-整理”算法。<br>这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 <strong>Parallel Scavenge</strong> 收集器一直<br>处于比较尴尬的状态。 原因是，如果新生代选择了<strong>Parallel Scavenge</strong> 收集器，老年代除了<br><strong>Serial Old</strong> 收集器外别无选择。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260003.png" alt=""></p>
<h2 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h2><p><strong>CMS（Concurrent Mark Sweep）</strong>收集器是一种以获取最短回收停顿时间为目标的收集器。   </p>
<p>其工作步骤分为以下四步：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep） </li>
</ul>
<p>其中，初始标记、 重新标记这两个步骤仍然需要“Stop The World”。 初始标记仅仅只是标记一下<strong>GC Roots</strong> 能直接关联到的对象，速度很快，并发标记阶段就是进行 <strong>GC RootsTracing</strong> 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260004.png" alt=""></p>
<h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h2><p><strong>G1</strong> 是一款面向服务端应用的垃圾收集器。 <strong>HotSpot</strong> 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 <strong>JDK 1.5</strong> 中发布的 <strong>CMS</strong> 收集器。 与 <strong>CMS</strong> 收集器相比，<strong>G1</strong>具备如下特点。 </p>
<ul>
<li>空间整合：与 <strong>CMS</strong> 的“标记—清理”算法不同，<strong>G1</strong> 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个<strong>Region</strong>之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 <strong>G1</strong> 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 <strong>GC</strong>。</li>
<li>可预测的停顿：这是 <strong>G1</strong> 相对于 <strong>CMS</strong> 的另一大优势，降低停顿时间是 <strong>G1</strong> 和 <strong>CMS</strong> 共同的关注点，但 <strong>G1</strong> 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 <strong>Java（RTSJ）</strong>的垃圾收集器的特征了。</li>
</ul>
<p>值得一提的是，在 <strong>G1</strong> 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 <strong>G1</strong> 不再是这样。 使用 <strong>G1</strong> 收集器时，<strong>Java</strong> 堆的内存布局就与其他收集器有很大差别，它将整个 <strong>Java</strong> 堆划分为多个大小相等的独立区域（<strong>Region</strong>），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 <strong>Region</strong>（不需要连续）的集合。 </p>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation） </li>
</ul>
<p>前三个阶段与 <strong>CMS</strong> 收集器相似，最后在筛选回收阶段首先对各个<strong>Region</strong> 的回收价值和成本进行排序，<br>根据用户所期望的 <strong>GC</strong> 停顿时间来制定回收计划。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260005.png" alt=""></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/垃圾回收/">垃圾回收</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-蓝牙协议入门（三）中介层协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/06/蓝牙协议入门（三）中介层协议/">蓝牙协议入门（三）中介层协议</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/07/06/蓝牙协议入门（三）中介层协议/" class="article-date">
  <time datetime="2017-07-05T17:38:37.000Z" itemprop="datePublished">2017-07-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-主机控制接口协议-HCI"><a href="#1-主机控制接口协议-HCI" class="headerlink" title="1.主机控制接口协议 HCI"></a>1.主机控制接口协议 HCI</h2><p>常用蓝牙控制器接口数据分组分为三类，分别为：</p>
<ul>
<li>指令分组（0x01）</li>
<li>事件分组（0x04）</li>
<li>数据分组（ACL：0x02，SCO：0x03）</li>
</ul>
<p>全部分组类型列举如下：</p>
<table>
<thead>
<tr>
<th>HCI 分组类型</th>
<th>RS232分组指示器</th>
</tr>
</thead>
<tbody>
<tr>
<td>HCI指令分组</td>
<td>0x01</td>
</tr>
<tr>
<td>HCI ACL数据分组</td>
<td>0x02</td>
</tr>
<tr>
<td>HCI SCO数据分组</td>
<td>0x03</td>
</tr>
<tr>
<td>HCI事件分组</td>
<td>0x04</td>
</tr>
<tr>
<td>HCI错误消息分组</td>
<td>0x05</td>
</tr>
<tr>
<td>HCI协商分组</td>
<td>0x06</td>
</tr>
</tbody>
</table>
<h3 id="1-1-指令分组"><a href="#1-1-指令分组" class="headerlink" title="1.1.指令分组"></a>1.1.指令分组</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280001.png" alt=""></p>
<p>如：<strong>Accpet Connection Request</strong></p>
<ul>
<li><strong>Opcode</strong> 为：<strong>0x0409</strong></li>
<li>参数长度为: <strong>07</strong> <ul>
<li>参数中蓝牙地址为：<strong>00:0d:fd:5f:16:9f</strong></li>
</ul>
</li>
<li>角色为：从设备  <strong>0x01</strong></li>
</ul>
<p>则大端数据模式指令为：<strong>09 04 07 9f 16 5f fd 0d 00 01</strong></p>
<h3 id="1-2-事件分组"><a href="#1-2-事件分组" class="headerlink" title="1.2.事件分组"></a>1.2.事件分组</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280002.png" alt=""></p>
<p>如：<strong>Accpet Connection Request</strong></p>
<ul>
<li><strong>Opcode :0x0409</strong></li>
<li>状态： <strong>0x00</strong></li>
<li>总长度： <strong>4</strong> 字节</li>
<li>命令状态：<strong>0x0f</strong></li>
</ul>
<p>则分组为： <strong>04 0f 04 00 01 09 04</strong></p>
<h3 id="1-3-数据分组"><a href="#1-3-数据分组" class="headerlink" title="1.3.数据分组"></a>1.3.数据分组</h3><p><strong>ACL</strong> 数据分组（注：<strong>PB =  Packet_Boundary</strong> ； <strong>BC =  Broadcast Flag</strong>）</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280003.png" alt=""></p>
<p><strong>SCO</strong> 数据分组</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280004.png" alt=""></p>
<h2 id="2-逻辑链路控制与适配协议-L2CAP"><a href="#2-逻辑链路控制与适配协议-L2CAP" class="headerlink" title="2.逻辑链路控制与适配协议  L2CAP"></a>2.逻辑链路控制与适配协议  L2CAP</h2><p><strong>L2CAP</strong> 位于基带之上，将基带的数据分组转换为便于高层应用的数据分组格式，并提供协议复用和服务质量交换等功能。<strong>L2CAP</strong> 只支持 <strong>ACL</strong> 数据传输，不支持 <strong>SCO</strong> 数据。<strong>L2CAP</strong> 本身不提供加强信道可靠性和保证数据完整性的机制，其信道的可靠性依靠基带提供。</p>
<p><strong>L2CAP</strong> 主要实现以下功能：</p>
<ol>
<li><strong>协议复用</strong>：底层传输协议没有提供对高层协议的复用机制，因而 L2CAP 支持高层协议复用，L2CAP 层可以区分其上的 SDP、RFCOMM、TCS 等。</li>
<li><strong>分段重组</strong>：L2CAP层帮助实现基带的短 PDU 和高层的长 PDU 相互传输，L2CAP 本身不完成任何 PDU 的分段重组，具体的分段重组有低层和高层来完成。</li>
<li><strong>服务质量 Qualityof Serivce 信息的交换</strong>：蓝牙建立连接的过程中，L2CAP允许交互蓝牙所期望的服务质量，建立完成后，通过监视资源的使用情况，来保证服务质量。</li>
<li><strong>组抽象</strong>：<strong>L2CAP</strong> 忽略地址组概念，他只关心数据。</li>
</ol>
<p><strong>L2CAP</strong> 信道有三种类型：</p>
<ul>
<li>面向连接信道：<strong>Connection-Oriented CO</strong>，用于两个设备之间的数据通信。</li>
<li>无连接信道：<strong>Connection-LessCL</strong>，用来向一组设备广播方式传输数据。<strong>CID</strong>为固定值：<strong>0x0002。</strong></li>
<li>信令信道：<strong>Signaling</strong>，用于创建 <strong>CO</strong> 通道，可以通过协商改变 <strong>CO</strong> 信道的特性。</li>
</ul>
<p>协议数据单元：</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280005.png" alt=""></p>
<h2 id="3-服务发现协议-SDP"><a href="#3-服务发现协议-SDP" class="headerlink" title="3.服务发现协议   SDP"></a>3.服务发现协议   SDP</h2><p>SDP两种服务发现模式：            </p>
<ul>
<li>服务搜索：查询具有特定服务属性的服务；            </li>
<li>服务浏览：简单的浏览全部可用服务。</li>
</ul>
<p>其 <strong>PDU</strong> （协议数据单元）格式为：</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280006.png" alt=""></p>
<p>不同的 <strong>PDU ID</strong> 的意义为：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Parameter Descirption</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>Reserved</td>
<td>保留</td>
</tr>
<tr>
<td>0x01</td>
<td>SDP_ErrorResponse</td>
<td>错误响应</td>
</tr>
<tr>
<td>0x02</td>
<td>SDP_ServiceSearchRequest</td>
<td>服务搜索请求</td>
</tr>
<tr>
<td>0x03</td>
<td>SDP_ServiceSearchResponse</td>
<td>服务搜索响应</td>
</tr>
<tr>
<td>0x04</td>
<td>SDP_ServiceAttributeRequest</td>
<td>服务属性请求</td>
</tr>
<tr>
<td>0x05</td>
<td>SDP_ServiceAttributeResponse</td>
<td>服务属性响应</td>
</tr>
<tr>
<td>0x06</td>
<td>SDP_ServiceSearchAttributeRequest</td>
<td>服务搜索属性请求</td>
</tr>
<tr>
<td>0x07</td>
<td>SDP_ServiceSearchAttributeResponse</td>
<td>服务搜索属性响应</td>
</tr>
<tr>
<td>0x08-0xff</td>
<td>Reserved</td>
<td>保留</td>
</tr>
</tbody>
</table>
<h2 id="4-串口仿真协议-RFCOMM"><a href="#4-串口仿真协议-RFCOMM" class="headerlink" title="4.串口仿真协议   RFCOMM"></a>4.串口仿真协议   RFCOMM</h2><p><strong>RFCOMM</strong> 是为建立在串口之上的传统应用提供环境接口，使他们可以做比较少协议改动就可以在蓝牙无线通信无线链路上工作。多路串口仿真是 <strong>RFCOMM</strong> 的重要功能，通过多路复用器(<strong>multiplexer</strong>)，一条 <strong>L2CAP</strong> 链路可以同时 多个串行应用。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280007.png" alt=""></p>
<p><strong>RFCOMM</strong> 两个蓝牙设备之间可以支持多达60多路仿真串口。<strong>RFCOMM</strong> 帧类型如下：</p>
<table>
<thead>
<tr>
<th>SABM</th>
<th>异步平衡模式设置指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>UA</td>
<td>未加编号的确认响应</td>
</tr>
<tr>
<td>DM</td>
<td>断开连接模式响应</td>
</tr>
<tr>
<td>DISC</td>
<td>断开连接指令</td>
</tr>
<tr>
<td>UIH</td>
<td>带头校验的未编号信息命令和响应</td>
</tr>
</tbody>
</table>
<h2 id="X-参考连接"><a href="#X-参考连接" class="headerlink" title="X.参考连接"></a>X.参考连接</h2><p><a href="http://blog.csdn.net/xubin341719/article/details/38305331" target="_blank" rel="external">蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/蓝牙/">蓝牙</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-TCP的三次握手与四次挥手" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/TCP的三次握手与四次挥手/">TCP的三次握手与四次挥手</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/06/28/TCP的三次握手与四次挥手/" class="article-date">
  <time datetime="2017-06-28T09:49:08.000Z" itemprop="datePublished">2017-06-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-TCP-建立与断开流程"><a href="#1-TCP-建立与断开流程" class="headerlink" title="1.TCP 建立与断开流程"></a>1.TCP 建立与断开流程</h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201706280001.png" alt="figure"></p>
<h2 id="2-为什么是三次握手"><a href="#2-为什么是三次握手" class="headerlink" title="2.为什么是三次握手"></a>2.为什么是三次握手</h2><p><strong>如果两次握手</strong>，那么只要客户端发送请求，就会建立连接。在这种情况下，如果有请求在信道上发生滞留，服务端就会收到一个失效的报文端，并误以为是客户端新的请求。由于客户端并不会对服务端的响应进行应答，所以在这种情况下，服务端以为连接建立了，而客户端并没有发出连接请求，所以永远也不会想服务端发送数据。</p>
<p>所以，三次握手是保证双方能够就发送数据这一问题达成一致所需要的最小值。</p>
<h2 id="3-为什么是四次挥手"><a href="#3-为什么是四次挥手" class="headerlink" title="3.为什么是四次挥手"></a>3.为什么是四次挥手</h2><p>因为 <strong>TCP</strong> 是双工协议，当客户端没有想要发送的东西的时候，服务端可能还有想发送的东西。所以客户端只能单方面地承诺自己不再发送。而 <strong>TCP</strong> 真正的结束应该是服务端也承诺不再发送并得到应答才可以。</p>
<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4.参考链接"></a>4.参考链接</h2><p><a href="http://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="external">TCP的三次握手(建立连接）和四次挥手(关闭连接）</a></p>
<p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="external">TCP 为什么是三次握手，为什么不是两次或四次？</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-JVM中如何判断一个对象是否可以回收" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/JVM中如何判断一个对象是否可以回收/">JVM中如何判断一个对象是否可以回收</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/06/28/JVM中如何判断一个对象是否可以回收/" class="article-date">
  <time datetime="2017-06-28T07:59:24.000Z" itemprop="datePublished">2017-06-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-根搜索算法"><a href="#1-根搜索算法" class="headerlink" title="1.根搜索算法"></a>1.根搜索算法</h2><p><strong>根搜索算法</strong> 是 <strong>JVM</strong> 虚拟机判断一个对象是否存活的算法。它把内存中的每一个对象看成一个节点，并定义了一些对象作为根节点（<strong>GC Roots</strong>）。</p>
<p>如果一个对象中有对另一个对象中的引用，那么就认为第一个对象有一条指向第二个对象的边。<strong>JVM</strong>会起一个线程从所有的<strong>GC Roots</strong>开始往下遍历，当遍历完之后如果发现有一些对象不可到达，那么就认为这些对象已经没有用了，需要被回收。</p>
<h2 id="2-哪些点可以被作为-GC-Roots"><a href="#2-哪些点可以被作为-GC-Roots" class="headerlink" title="2.哪些点可以被作为 GC Roots"></a>2.哪些点可以被作为 GC Roots</h2><h3 id="2-1-Java-虚拟机栈中引用的对象"><a href="#2-1-Java-虚拟机栈中引用的对象" class="headerlink" title="2.1.Java 虚拟机栈中引用的对象"></a>2.1.Java 虚拟机栈中引用的对象</h3><p>首先第一种是虚拟机栈中的引用的对象，我们在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。</p>
<h3 id="2-2-方法区中的静态成员"><a href="#2-2-方法区中的静态成员" class="headerlink" title="2.2.方法区中的静态成员"></a>2.2.方法区中的静态成员</h3><p>第二种是我们在类中定义了全局的静态的对象，也就是使用了<strong>static</strong> 关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为<strong>GC Roots</strong>是必须的。</p>
<h3 id="2-3-方法区中的常量引用对象"><a href="#2-3-方法区中的常量引用对象" class="headerlink" title="2.3.方法区中的常量引用对象"></a>2.3.方法区中的常量引用对象</h3><p>第三种便是常量引用，就是使用了<strong>static final</strong> 关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为<strong>GC Roots</strong>。</p>
<h3 id="2-4-本地方法区中的-JNI（Native-方法）引用的对象"><a href="#2-4-本地方法区中的-JNI（Native-方法）引用的对象" class="headerlink" title="2.4.本地方法区中的 JNI（Native 方法）引用的对象"></a>2.4.本地方法区中的 JNI（Native 方法）引用的对象</h3><p>最后一种是在使用 <strong>JNI</strong> 技术时，有时候单纯的 <strong>Java</strong> 代码并不能满足我们的需求，我们可能需要在 <strong>Java</strong> 中调用 <strong>C</strong> 或 <strong>C++</strong> 的代码，因此会使用 <strong>native</strong>方法，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为<strong>GC Roots</strong>。</p>
<h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h2><p> <a href="http://blog.csdn.net/u011277123/article/details/53908315" target="_blank" rel="external">JVM如何判断一个Java对象是否可以回收</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可达性分析算法/">可达性分析算法</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-Linux常用指令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/Linux常用指令/">Linux常用指令</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/06/28/Linux常用指令/" class="article-date">
  <time datetime="2017-06-28T07:38:37.000Z" itemprop="datePublished">2017-06-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-目录相关的命令"><a href="#1-目录相关的命令" class="headerlink" title="1.目录相关的命令"></a>1.目录相关的命令</h2><p>首先，我们要建立一个叫做 mydir 的文件夹，然后建立一个叫做 myfile 的文件。之后再把这个文件夹及其中的文件删除掉。</p>
<p>按住 Ctrl + Alt + T，打开一个端口，然后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls -l</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280008.png" alt=""></p>
<p>通过 ls 命令，我们就可以查看当前目录下的文件和目录（要不然怎么知道建立和删除是否成功了呢，是吧）。然后我们开始建立文件夹。输入 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir mydir</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280009.png" alt=""></p>
<p>看起来并没有发生什么，现在我们来 ls 一下看看我们是否成功建立了自己的文件夹。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280010.png" alt=""></p>
<p>好，既然我们已经有了自己的文件夹了，那就进去建立一个文件吧。进入文件夹的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd mydir</div></pre></td></tr></table></figure>
<p>进去之后，我们来创建一个文件，命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi myfile.txt</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280011.png" alt=""></p>
<p>于是我们就进入了 vim 的界面。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280012.png" alt=""></p>
<p>关于 vim 的操作以前已经介绍过了，这里不再赘述。按下 i 进入插入模式，输入 hello 。然后按 Esc 到命令模式，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:wq</div></pre></td></tr></table></figure>
<p>保存退出。然后我们再 ls 一下，就能看见我们刚刚创建的文件了。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280013.png" alt=""></p>
<p>现在我们已经建立了新的文件，然后我们要删掉它。在 linux 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rm fliename // 删除文件</div><div class="line">$ rmdir filename // 删除文件夹</div></pre></td></tr></table></figure>
<p>但是我们如果碰到想要删除一个文件夹，而这个文件夹中又有很多文件的情况，处理起来就会很麻烦了。这时我们就需要一个新的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm -rf dirname //删除文件夹及其中所有文件</div></pre></td></tr></table></figure>
<p>尝试一下，不过为了删除当前的目录，我们必须返回上一级目录中。输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd ../</div></pre></td></tr></table></figure>
<p>返回上级目录之后，删除该文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm -rf mydir</div></pre></td></tr></table></figure>
<p>这时整个文件夹已经被我们删除了。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280014.png" alt=""></p>
<h2 id="2-字符串匹配-grep"><a href="#2-字符串匹配-grep" class="headerlink" title="2.字符串匹配 grep"></a>2.字符串匹配 grep</h2><p>grep 可以过滤出你想要的东西，举个例子，我想要在当前目录下找到所有名字中带 Mu 的文件或文件夹，那么我们就可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls | grep Mu</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280015.png" alt=""></p>
<h2 id="3-进程相关指令-ps"><a href="#3-进程相关指令-ps" class="headerlink" title="3.进程相关指令 ps"></a>3.进程相关指令 ps</h2><p>ps 是显示进程的指令，可以根据不同的参数调节想要显示的进程种类，显示所有进程的指令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ps aux</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280016.png" alt=""></p>
<p>加入我只想看跟自己相关的进程呢？后面加个 grep 就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ps aux | grep jack</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280017.png" alt=""></p>
<h2 id="4-查看文件"><a href="#4-查看文件" class="headerlink" title="4.查看文件"></a>4.查看文件</h2><p>我们可以通过 cat 命令来查看文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat fliename</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280018.png" alt=""></p>
<p>当然，我们也可以通过 tail 显示文件的最后几行。如果加上参数 -f ，就能不断地读取最新的内容，达到实时监视的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tail -f filename</div></pre></td></tr></table></figure>
<h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5.参考链接"></a>5.参考链接</h2><p><a href="http://www.cnblogs.com/wangkangluo1/archive/2012/05/26/2518856.html" target="_blank" rel="external">linux tail 命令详解</a></p>
<p> <a href="http://blog.csdn.net/ljianhui/article/details/11100625" target="_blank" rel="external">初窥Linux 之 我最常用的20条命令</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-MySQL基础之数据库的隔离级别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/27/MySQL基础之数据库的隔离级别/">MySQL基础之数据库的隔离级别</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/06/27/MySQL基础之数据库的隔离级别/" class="article-date">
  <time datetime="2017-06-27T14:17:14.000Z" itemprop="datePublished">2017-06-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-隔离级别"><a href="#1-隔离级别" class="headerlink" title="1.隔离级别"></a>1.隔离级别</h2><p>数据库的隔离级别有以下四种：</p>
<ol>
<li>读未提交</li>
<li>读已提交</li>
<li>可重复读</li>
<li>串行化</li>
</ol>
<h2 id="2-数据库读取中的问题"><a href="#2-数据库读取中的问题" class="headerlink" title="2.数据库读取中的问题"></a>2.数据库读取中的问题</h2><p>隔离级别主要用来解决以下三个问题：</p>
<ol>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ol>
<h3 id="2-1-最简单情况"><a href="#2-1-最简单情况" class="headerlink" title="2.1.最简单情况"></a>2.1.最简单情况</h3><p>最简单的情况就是<strong>读未提交</strong>，其本质是：</p>
<p><strong>事务在修改数据的时候只对数据增加行级共享锁。</strong></p>
<p><strong>事务在读数据的时候并未对数据加锁。</strong></p>
<p><strong>读未提交</strong>会引起脏读的问题。</p>
<h3 id="2-2-脏读"><a href="#2-2-脏读" class="headerlink" title="2.2.脏读"></a>2.2.脏读</h3><p>假设 <strong>A</strong> 给 <strong>B</strong> 打 <strong>5000</strong> 块钱，修改了数据库当时还没有提交。此时 <strong>B</strong> 读取数据库中的自己账户的余额，以为自己收到了 <strong>5000</strong> 块钱。然而之后 <strong>A</strong> 并没有提交，而是回滚了该数据，所以最终 <strong>B</strong> 的账余额并没有增加。所以 <strong>B</strong> 读取到的是错误的信息，这就是<strong>脏读</strong>。</p>
<p>为了避免这种情况，需要把数据库的隔离级别设置为<strong>读已提交</strong>。其本质是：</p>
<p><strong>事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁。</strong></p>
<p><strong>事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</strong></p>
<h3 id="2-3-不可重复读"><a href="#2-3-不可重复读" class="headerlink" title="2.3.不可重复读"></a>2.3.不可重复读</h3><p>假设一个账户中有 <strong>5000</strong> 块钱， <strong>A</strong> 和 <strong>B</strong> 同时从这个账户中取钱，当 A 查看余额时发现账户中有 <strong>5000</strong> 块钱，之后 <strong>B</strong> 取走了这 <strong>5000</strong> 块钱，当 <strong>A</strong> 再取钱的时候发现钱已经被取走了。也就是说，在同一事务中，<strong>A</strong> 对自己的账户进行的两次查询得到了不同的结果，这就是<strong>不可重复读</strong>。</p>
<p>为了避免这种情况，需要把数据库的隔离级别设置为<strong>可重复读</strong>。其本质是：</p>
<p><strong>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。</strong></p>
<p><strong>事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</strong></p>
<p><strong>不可重复读</strong>与<strong>脏读</strong>的区别在于，脏读读出的数据是<strong>无效的未提交的信息</strong>（脏读也称为<strong>无效数据读出</strong>）。而不可重复读两次读取的信息都是<strong>有效的已提交的信息</strong>，只不过在这两次读取期间数据被提交了而已。</p>
<p><strong>可重复读</strong>和<strong>读已提交</strong>最大的区别就在于事务在读的过程中<strong>行级共享锁的寿命</strong>。读已提交是读取完就释放，而可重复读是事务结束才释放，</p>
<h3 id="2-4-幻读"><a href="#2-4-幻读" class="headerlink" title="2.4.幻读"></a>2.4.幻读</h3><p>假设 <strong>A</strong> 正在查询自己银行卡中的本月的消费记录，恰好此时 <strong>B</strong> 拿着 <strong>A</strong> 的信用卡刷了一笔钱。也就是说，在同一事务中，<strong>A</strong> 读到的两次消费记录不一致。新的结果中出现了<strong>幻影行</strong>，这就是<strong>幻读</strong>。</p>
<p>为了避免这种情况，需要把数据库的隔离级别设置为<strong>串行化</strong>。其本质是：</p>
<p><strong>事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</strong></p>
<p><strong>事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</strong></p>
<p><strong>幻读</strong>与<strong>不可重复读</strong>的区别在于，不可重复读可以通过对读取到的数据加锁来避免。然而，<strong>你不可能给一条还未插入到数据库中的数据进行加锁</strong>，因此幻读是无法通过这种机制来避免，所以才要锁全表。</p>
<h2 id="3-数据库的默认隔离级别"><a href="#3-数据库的默认隔离级别" class="headerlink" title="3.数据库的默认隔离级别"></a>3.数据库的默认隔离级别</h2><p><strong>MySQL</strong> 的默认隔离级别是可重复读.</p>
<p>大多数数据库如 <strong>Sql Server</strong> , <strong>Oracle</strong> 的默认级别是读已提交。</p>
<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4.参考链接"></a>4.参考链接</h2><p><a href="http://blog.csdn.net/fg2006/article/details/6937413" target="_blank" rel="external">数据库事务隔离级别</a></p>
<p><a href="http://www.hollischuang.com/archives/943" target="_blank" rel="external">深入分析事务的隔离级别</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/隔离级别/">隔离级别</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-Java基础之Synchronized与ReentrantLock的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/27/Java基础之Synchronized与ReentrantLock的区别/">Java基础之Synchronized与ReentrantLock的区别</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/06/27/Java基础之Synchronized与ReentrantLock的区别/" class="article-date">
  <time datetime="2017-06-27T10:38:37.000Z" itemprop="datePublished">2017-06-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-不同同步手段之间的区别"><a href="#1-不同同步手段之间的区别" class="headerlink" title="1.不同同步手段之间的区别"></a>1.不同同步手段之间的区别</h2><h3 id="1-1-Synchronized"><a href="#1-1-Synchronized" class="headerlink" title="1.1.Synchronized"></a>1.1.Synchronized</h3><p>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，<strong>synchronized</strong> 是很合适的。</p>
<ol>
<li>原因在于，编译程序通常会尽可能的进行优化 <strong>synchronized</strong>，</li>
<li><strong>synchronized</strong> 另外可读性非常好。</li>
</ol>
<h3 id="1-2-ReentrantLock"><a href="#1-2-ReentrantLock" class="headerlink" title="1.2.ReentrantLock"></a>1.2.ReentrantLock</h3><p><strong>ReentrantLock</strong> 适用于资源竞争比较激烈的情况。</p>
<ol>
<li>在资源竞争不激烈的情形下，性能稍微比<strong>synchronized</strong>差点点。</li>
<li>当同步非常激烈的时候，<strong>synchronized</strong> 的性能一下子能下降好几十倍。而 <strong>ReentrantLock</strong> 还能维持常态。</li>
<li>可以实现多样化的同步，比如<strong>有时间限制的</strong>同步，可以被 <strong>Interrupt</strong> 的同步等。</li>
</ol>
<h3 id="1-3-Atomic"><a href="#1-3-Atomic" class="headerlink" title="1.3.Atomic"></a>1.3.Atomic</h3><p><strong>Atomic</strong> 同样适用于资源竞争比较激烈的情况。</p>
<ol>
<li>不激烈情况下，性能比<strong>synchronized</strong> 略逊。</li>
<li>资源竞争激烈的时候，也能维持常态。<strong>Atomic</strong> 的性能会优于<strong>ReentrantLock</strong>一倍左右。</li>
<li><strong>Atomic</strong> 有一个缺点，就是只能同步一个值，一段代码中只能出现一个<strong>Atomic</strong> 的变量，多于一个同步无效。因为他不能在多个<strong>Atomic</strong>之间同步。</li>
</ol>
<h2 id="2-RentranLock-的使用方式"><a href="#2-RentranLock-的使用方式" class="headerlink" title="2.RentranLock 的使用方式"></a>2.RentranLock 的使用方式</h2><ol>
<li><strong>lock()</strong> ，如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</li>
<li><strong>tryLock()</strong> ，如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false。</li>
<li><strong>tryLock(long timeout,TimeUnit unit)</strong>， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false。</li>
<li><strong>lockInterruptibly()</strong> ，如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断。</li>
</ol>
<h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h2><p><a href="http://www.cnblogs.com/nsw2018/p/5821738.html" target="_blank" rel="external">Lock与synchronized 的区别</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lock/">Lock</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Synchronized/">Synchronized</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Jack Smith&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>