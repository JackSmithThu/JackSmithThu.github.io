<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Jackie</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Jackie">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jackie">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jackie">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-国内crm系统调研小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/21/国内crm系统调研小结/">国内 CRM 系统调研小结</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/11/21/国内crm系统调研小结/" class="article-date">
  <time datetime="2017-11-21T10:11:39.000Z" itemprop="datePublished">2017-11-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/产品/">产品</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-界面设计"><a href="#1-界面设计" class="headerlink" title="1.界面设计"></a>1.界面设计</h2><h3 id="1-1-Salesforce"><a href="#1-1-Salesforce" class="headerlink" title="1.1.Salesforce"></a>1.1.Salesforce</h3><p>如果让我给我使用过的所有 CRM 软件的界面做个排名，SalesForce 的界面是稳稳能占据前两名的。它的界面看上去给人的感觉就是两个字：<strong>专业</strong>。</p>
<h4 id="1-1-1-主页"><a href="#1-1-1-主页" class="headerlink" title="1.1.1.主页"></a>1.1.1.主页</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Saleforce-主页.jpg" alt=""></p>
<h4 id="1-1-2-客户列表"><a href="#1-1-2-客户列表" class="headerlink" title="1.1.2.客户列表"></a>1.1.2.客户列表</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Saleforce-客户.jpg" alt=""></p>
<h4 id="1-1-3-新建客户"><a href="#1-1-3-新建客户" class="headerlink" title="1.1.3.新建客户"></a>1.1.3.新建客户</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Saleforce-新建客户.jpg" alt=""></p>
<h4 id="1-1-4-新建任务"><a href="#1-1-4-新建任务" class="headerlink" title="1.1.4.新建任务"></a>1.1.4.新建任务</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Saleforce-新建任务.jpg" alt=""></p>
<h3 id="1-2-爱客"><a href="#1-2-爱客" class="headerlink" title="1.2.爱客"></a>1.2.爱客</h3><p>爱客的整体画风也比较简洁，虽然看上去像是套用了某个前端的模板，但总的来说还是比较专业的。</p>
<h4 id="1-2-1-工作台"><a href="#1-2-1-工作台" class="headerlink" title="1.2.1.工作台"></a>1.2.1.工作台</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/爱客-工作台.jpg" alt=""></p>
<h4 id="1-2-2-客户列表"><a href="#1-2-2-客户列表" class="headerlink" title="1.2.2.客户列表"></a>1.2.2.客户列表</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/爱客-客户.jpg" alt=""></p>
<h4 id="1-2-3-客户详情"><a href="#1-2-3-客户详情" class="headerlink" title="1.2.3.客户详情"></a>1.2.3.客户详情</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/爱客-客户详情.jpg" alt=""></p>
<h4 id="1-2-4-新增客户"><a href="#1-2-4-新增客户" class="headerlink" title="1.2.4.新增客户"></a>1.2.4.新增客户</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/爱客-新增客户.jpg" alt=""></p>
<h4 id="1-2-5-跟进"><a href="#1-2-5-跟进" class="headerlink" title="1.2.5.跟进"></a>1.2.5.跟进</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/爱客-跟进.jpg" alt=""></p>
<h4 id="1-2-6-写跟进"><a href="#1-2-6-写跟进" class="headerlink" title="1.2.6.写跟进"></a>1.2.6.写跟进</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/爱客-写跟进.jpg" alt=""></p>
<h3 id="1-3-Xtools"><a href="#1-3-Xtools" class="headerlink" title="1.3.Xtools"></a>1.3.Xtools</h3><p>如果说谁能在前端界面上能够跟 Salesforce 媲美的话，那一定就是 Xtools。Xtools 的界面在细节的处理上特别完善，使用起来也很流畅。</p>
<h4 id="1-3-1-工作台"><a href="#1-3-1-工作台" class="headerlink" title="1.3.1.工作台"></a>1.3.1.工作台</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Xtools-主页.jpg" alt=""></p>
<h4 id="1-3-2-客户列表"><a href="#1-3-2-客户列表" class="headerlink" title="1.3.2.客户列表"></a>1.3.2.客户列表</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Xtools-客户.jpg" alt=""></p>
<h4 id="1-3-3-客户详情"><a href="#1-3-3-客户详情" class="headerlink" title="1.3.3.客户详情"></a>1.3.3.客户详情</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Xtools-客户详情.jpg" alt=""></p>
<h4 id="1-3-4-新建客户"><a href="#1-3-4-新建客户" class="headerlink" title="1.3.4.新建客户"></a>1.3.4.新建客户</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Xtools-新建客户.jpg" alt=""></p>
<h3 id="1-4-悟空"><a href="#1-4-悟空" class="headerlink" title="1.4.悟空"></a>1.4.悟空</h3><p>悟空的使用感受给人的印象就是：流畅。无论是开通试用的过程还是软件的使用过程，流畅到让你觉得你可能落入了一个精心设计的陷阱。开玩笑地说，真是如丝般顺滑（笑）。</p>
<h4 id="1-4-1-主页"><a href="#1-4-1-主页" class="headerlink" title="1.4.1.主页"></a>1.4.1.主页</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/悟空-主页.jpg" alt=""></p>
<h4 id="1-4-2-客户列表"><a href="#1-4-2-客户列表" class="headerlink" title="1.4.2.客户列表"></a>1.4.2.客户列表</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/悟空-客户.jpg" alt=""></p>
<h4 id="1-4-3-新建客户"><a href="#1-4-3-新建客户" class="headerlink" title="1.4.3.新建客户"></a>1.4.3.新建客户</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/悟空-新建客户.jpg" alt=""></p>
<h4 id="1-4-4-跟进"><a href="#1-4-4-跟进" class="headerlink" title="1.4.4.跟进"></a>1.4.4.跟进</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/悟空-跟进.jpg" alt=""></p>
<h3 id="1-5-亿客"><a href="#1-5-亿客" class="headerlink" title="1.5.亿客"></a>1.5.亿客</h3><p>亿客采用纯蓝色“复古”画风，看起来比它的竞争对手落后了一个时代。不过它的功能还是比较完善的。</p>
<h4 id="1-5-1-首页"><a href="#1-5-1-首页" class="headerlink" title="1.5.1.首页"></a>1.5.1.首页</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/亿客-首页.jpg" alt=""></p>
<h4 id="1-5-2-客户列表"><a href="#1-5-2-客户列表" class="headerlink" title="1.5.2.客户列表"></a>1.5.2.客户列表</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/亿客-客户.jpg" alt=""></p>
<h4 id="1-5-3-新建客户"><a href="#1-5-3-新建客户" class="headerlink" title="1.5.3.新建客户"></a>1.5.3.新建客户</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/亿客-新建客户.jpg" alt=""></p>
<h4 id="1-5-4-记录"><a href="#1-5-4-记录" class="headerlink" title="1.5.4.记录"></a>1.5.4.记录</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/亿客-记录.jpg" alt=""></p>
<h3 id="1-6-八百客"><a href="#1-6-八百客" class="headerlink" title="1.6.八百客"></a>1.6.八百客</h3><p>八百客的界面风格实在是太古老了，虽然它的功能也很完善，但是我们这里就不详细描述了。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/八百客-原始界面设计.jpg" alt=""></p>
<h2 id="2-用户数量"><a href="#2-用户数量" class="headerlink" title="2.用户数量"></a>2.用户数量</h2><p>大多数网站没有公布自己的用户数量信息，不过我们可以通过流量来进行推测。由于网上的数据并不是很全面，这里我们只展示出我们能拿到的数据。</p>
<h4 id="2-1-分享销客-VS-爱客"><a href="#2-1-分享销客-VS-爱客" class="headerlink" title="2.1.分享销客 VS 爱客"></a>2.1.分享销客 VS 爱客</h4><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/分销客-爱客.jpg" alt=""></p>
<p>我们可以看到，分享销客的数量更多一点，但也只有 700 K / 月。我们做个大概的估计，假定每个用户平均三天上线一次（对于“活”的用户而言这已经是比较低的使用频率了），那么一个月就是 10 次。所以纷享销客的越活用户应该不会超过 70 万。如果按照每天上线一次来计算，那么它的用户数量大概在 10 万左右。</p>
<h3 id="2-2-泛微-VS-Salesforce"><a href="#2-2-泛微-VS-Salesforce" class="headerlink" title="2.2.泛微 VS Salesforce"></a>2.2.泛微 VS Salesforce</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/泛微-Salesforce.jpg" alt=""></p>
<p>泛微的月流量大概是 500 K 左右，跟纷享销客大概是一个量级。不过 Salesforce 这也太多了吧？ 100 多M？仔细核对了一下，force.com 下面有很多个子域名，其中最有可能和 Salesforce 相关的是 ：lightning.force.com。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/salesforce真实.jpg" alt=""></p>
<p>即使是这样流量还是很多，不过与其他 CRM 不同，它的流量主要来自于北美。这似乎违背了我们调研国内 CRM 系统的初衷。不过我在使用  Salesforce 的时候，觉得它的汉化已经很完善了。而且 SEO（搜索引擎优化）也做到了百度的前列。所以在我看来算作国内市场的 CRM 软件应该也不过分吧。</p>
<h2 id="3-价格"><a href="#3-价格" class="headerlink" title="3.价格"></a>3.价格</h2><p>各家 CRM 软件的价格都差不多，可能因为 Salesforce 习惯了用美元的缘故，折算成人民币要贵一点。以下是各家的价格：</p>
<h3 id="3-1-Salesforce-价格"><a href="#3-1-Salesforce-价格" class="headerlink" title="3.1.Salesforce 价格"></a>3.1.Salesforce 价格</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/salesforce价格.jpg" alt=""></p>
<h3 id="3-2-Xtools-价格"><a href="#3-2-Xtools-价格" class="headerlink" title="3.2.Xtools 价格"></a>3.2.Xtools 价格</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/Xtools-价格.jpg" alt=""></p>
<h3 id="3-1-亿客价格"><a href="#3-1-亿客价格" class="headerlink" title="3.1.亿客价格"></a>3.1.亿客价格</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/亿客-价格.jpg" alt=""></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>从目前的 CRM 软件市场来看，显然已经是一片红海。市场上已经进化出了比较完备的产品，而且在国内的价格也在可接收的范围之内。如果想要在这一领域划分出一块领地，就必须有比较大的创新点。否则可能就是死路一条。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CRM/">CRM</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-贴现现金流应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/15/贴现现金流应用/">贴现现金流应用</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/11/15/贴现现金流应用/" class="article-date">
  <time datetime="2017-11-15T08:57:55.000Z" itemprop="datePublished">2017-11-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/CFA/">CFA</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-净现值（NPV）"><a href="#1-净现值（NPV）" class="headerlink" title="1.净现值（NPV）"></a>1.净现值（NPV）</h2><p>净现值（NPV）是考虑资金收支净额，以及按照一定的折现率折现之后的现值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NPV = CF1/[(1 + r)^1] + CF2/[(1 + r)^2] + ... + CFn/[(1 + r)^n]</div></pre></td></tr></table></figure>
<p>其中 CFi 是第 i 年的现金流，r 是折现率，n 是投资的时间。</p>
<h2 id="2-内回报率（IRR）"><a href="#2-内回报率（IRR）" class="headerlink" title="2.内回报率（IRR）"></a>2.内回报率（IRR）</h2><p>内部回报率（IRR），指项目投资实际可望达到的收益率。实质上，它是能使项目的净现值等于零时的折现率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 = CF0 + CF1/[(1 + IRR)^1] + CF2/[(1 + IRR)^2] + ... + + CFn/[(1 + IRR)^n]</div></pre></td></tr></table></figure>
<p>其中 CFi 是第 i 年的现金流，r 是折现率，n 是投资的时间，IRR 是内回报率。</p>
<h2 id="3-接受和拒绝项目的标准"><a href="#3-接受和拒绝项目的标准" class="headerlink" title="3.接受和拒绝项目的标准"></a>3.接受和拒绝项目的标准</h2><ul>
<li><strong>对于独立（independent）项目，接受所有净现值（NPV）为正的项目。</strong>因为净现值为 0 意味着内回报率（IRR）等于投资者预期的回报率。<strong>所以这也意味着接收所有内回报率（IRR）大于预期回报率的项目。</strong></li>
</ul>
<ul>
<li><strong>对于互斥（mutually exclusive）项目，接受净现值（NPV）最高的项目。</strong></li>
</ul>
<h2 id="4-持有期汇报（Holding-Period-Return）"><a href="#4-持有期汇报（Holding-Period-Return）" class="headerlink" title="4.持有期汇报（Holding Period Return）"></a>4.持有期汇报（Holding Period Return）</h2><p>持有期汇报（HPR）等于利润（最终价值（ending value）与所有现金流（cash flow received）的总和与初始价值（beginning value）的差值）与初始价值的商。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HPR = (ending value + cash flow received - beginning value) / beginning value</div></pre></td></tr></table></figure>
<p>如果没有现金流，则持有期回报（HPR）等于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HPR = (ending value - beginning value) / beginning value</div></pre></td></tr></table></figure>
<h3 id="5-价值加权回报率（money-weighted-return）与时间加权回报率（time-weighted-return）"><a href="#5-价值加权回报率（money-weighted-return）与时间加权回报率（time-weighted-return）" class="headerlink" title="5.价值加权回报率（money-weighted return）与时间加权回报率（time-weighted return）"></a>5.价值加权回报率（money-weighted return）与时间加权回报率（time-weighted return）</h3><ul>
<li><p>价值加权回报率（money-weighted return）相当于对投资组合（investment portfolio）的内回报率（IRR）。即当：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PV-inflows = PV-outflows</div></pre></td></tr></table></figure>
<p>时得到的内回报率（IRR）。</p>
</li>
</ul>
<ul>
<li><p>时间加权回报率（time-weighted return）相当于每个复利周期的回报率的几何平均值。即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">time-weighted return = [(1 + HPR1) × (1 + HPR2) × ... × (1 + HPR2)] ^ (1/n)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-银行折现收益率（bank-discount-yield）、持有期收益率（holding-period-yield）、实际年收益（effective-annual-yield）和货币市场收益率（money-market-yield）"><a href="#6-银行折现收益率（bank-discount-yield）、持有期收益率（holding-period-yield）、实际年收益（effective-annual-yield）和货币市场收益率（money-market-yield）" class="headerlink" title="6.银行折现收益率（bank discount yield）、持有期收益率（holding period yield）、实际年收益（effective annual yield）和货币市场收益率（money market yield）"></a>6.银行折现收益率（bank discount yield）、持有期收益率（holding period yield）、实际年收益（effective annual yield）和货币市场收益率（money market yield）</h2><ul>
<li><p>银行折现收益率（bank discount yield，r-BD）等于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r-BD = [(F - P) / F] × (360 / t)</div></pre></td></tr></table></figure>
<p>其中，F 为纸面价格（即期末支付价格），P 为买入价格，t 为持有时间，一年以 360 天计。</p>
</li>
<li><p>持有期收益率（holding period yield，HPY）等于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HPY = [(F - P) / P]</div></pre></td></tr></table></figure>
<p>其中，F 为纸面价格（即期末支付价格），P 为购买价格，t 为持有时间，一年以 360 天计。与银行折现收益率（BDY）相比，持有期收益率（HPY）的分母是买入价格（P），更接近我们平常对收益率的认知。</p>
</li>
<li><p>实际年收益率（effective annual yield，EAY）等于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EAY = (1 + HPY) ^ (365 / t) = [(F - P) / P] ^ (365 / t)</div></pre></td></tr></table></figure>
<p>实际年收益率使用了复利的形式，而且以 365 天为一年。</p>
</li>
<li><p>货币市场收益率（money market yield，CD equivalent yield，r-MM）等于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r-MM = HPY × (360 / t) = [(F - P) / P] × (360 / t)</div></pre></td></tr></table></figure>
<p>货币时长收益率使用了单利的形式，以 360 天为一年。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>除以本金 / 纸面</strong></th>
<th><strong>单利 / 复利</strong></th>
<th><strong>一年 360 天 / 365 天</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>银行折现收益率</strong></td>
<td>纸面</td>
<td>单利</td>
<td>360</td>
</tr>
<tr>
<td><strong>货币市场收益率</strong></td>
<td>本金</td>
<td>单利</td>
<td>360</td>
</tr>
<tr>
<td><strong>持有期收益</strong></td>
<td>本金</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td><strong>实际年收益</strong></td>
<td>本金</td>
<td>复利</td>
<td>365</td>
</tr>
</tbody>
</table>
<h3 id="7-债券等值收益率（bond-equivalent-yield，BEY）"><a href="#7-债券等值收益率（bond-equivalent-yield，BEY）" class="headerlink" title="7.债券等值收益率（bond equivalent yield，BEY）"></a><strong>7.债券等值收益率（bond equivalent yield，BEY）</strong></h3><p>债券等值收益率（bond equivalent yield，BEY）等于半年度收益率（半年度收益率按照复利计算）的两倍。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NPV，IRR/">NPV，IRR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/零基础入门学习CFA/">零基础入门学习CFA</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-货币的时间价值" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/13/货币的时间价值/">货币的时间价值</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/11/13/货币的时间价值/" class="article-date">
  <time datetime="2017-11-13T08:57:55.000Z" itemprop="datePublished">2017-11-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/CFA/">CFA</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-复利"><a href="#1-复利" class="headerlink" title="1.复利"></a>1.复利</h2><p>货币的时间价值是建立在复利（<strong>compound interest</strong>）的基础之上的。所谓复利，就是复利计算中利息按照约定的计息周期参与计息。也就是我们平常说的“利滚利”或者“驴打滚”。</p>
<p>举个例子，一个人欠了 100 元的债务，年利率 10 %。如果按照复利计算，那么如果一年以后还清，则需要归还 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">100 × （100 % + 10 %） = 110 元。</div></pre></td></tr></table></figure>
<p>如果两年之后还清，则不仅需要支付当年本金产生的利息 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">100 × 10 % = 10 元</div></pre></td></tr></table></figure>
<p>还要支付上一年利息所产生的利息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 × 10 % = 1 元</div></pre></td></tr></table></figure>
<p>总共需要归还 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">100（本金） + 10（第一年本金产生的利息） + 10 （第二年本金产生的利息）+ 1（第一年利息产生的利息）= 121 元。</div></pre></td></tr></table></figure>
<h2 id="2-金钱的现值（PV）和未来值（FV）"><a href="#2-金钱的现值（PV）和未来值（FV）" class="headerlink" title="2.金钱的现值（PV）和未来值（FV）"></a>2.金钱的现值（PV）和未来值（FV）</h2><p>一个人欠了 100 元的债务，年利率 10 %。两年之后需要归还 121 元。 100 元就是这笔债务的现值价值（PV）。两年之后需要归还的 121 元就是这笔债务的未来值（FV）。</p>
<h2 id="3-复利周期数（N）和每周期复利利率（I-Y）"><a href="#3-复利周期数（N）和每周期复利利率（I-Y）" class="headerlink" title="3.复利周期数（N）和每周期复利利率（I/Y）"></a>3.复利周期数（N）和每周期复利利率（I/Y）</h2><p>一个人欠了 100 元的债务，年利率 10 %，约定两年之后归还。这里的复利周期数（N）就是 2，每周期复利利率（I/Y）就是 10 %。</p>
<h2 id="4-每期现金流（PMT）"><a href="#4-每期现金流（PMT）" class="headerlink" title="4.每期现金流（PMT）"></a>4.每期现金流（PMT）</h2><p>一个人欠了 100 元的债务，年利率 10 %。如果这个人选择分期付款，每年归还 57.62 元。那么这个 57.62 元就是每期现金流（PMT）。</p>
<h2 id="5-货币的时间价值（TVM）"><a href="#5-货币的时间价值（TVM）" class="headerlink" title="5.货币的时间价值（TVM）"></a>5.货币的时间价值（TVM）</h2><p>理想情况下，如果利率恒定为正，那么货币的价值随着时间的前进而增加，随着时间的倒退而减少。金钱的现值（PV）和未来值（FV）存在着如下关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FV = PV × (1 + I/Y) ^ N</div></pre></td></tr></table></figure>
<p>如果考虑每期现金流（PMT），则总的关系式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FV = PV × (1 + I/Y) ^ N + PMT × &#123;[(1 - I/Y) ^ N] / (1 - I/Y)&#125;</div></pre></td></tr></table></figure>
<h2 id="6-风险类型"><a href="#6-风险类型" class="headerlink" title="6.风险类型"></a>6.风险类型</h2><ol>
<li>默认风险：借贷者不能按期支付现金流的风险。</li>
<li>流动性风险：为了使资产快速变现而贬值产生的风险。</li>
<li>到期风险：由借贷时间带来的风险。一般而言，长期借贷的风险更高。</li>
</ol>
<h2 id="7-有效年利率（EAR）"><a href="#7-有效年利率（EAR）" class="headerlink" title="7.有效年利率（EAR）"></a>7.有效年利率（EAR）</h2><p>一个人欠了 100 元的债务，年利率 10 %。但是复利周期不是按年结算，而是按半年结算。则每一年中有两个复利周期，每个周期利率 5 %。那么一年之后，这个人需要偿还：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">100 × （100 % + 5 %）×（100 % + 5 %） = 110.25 元。</div></pre></td></tr></table></figure>
<p>所以，这个人实际每年支付的利率其实是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10.25 / 100 = 10.25 %</div></pre></td></tr></table></figure>
<p>这个 10.25 % 就是有效年利率（EAR）。假定年利率不变，则一年之内复利周期越多，那么有效年利率（EAR）就越高。</p>
<h2 id="8-普通年金（ordinary-annuity）与即付年金（annuity-due）"><a href="#8-普通年金（ordinary-annuity）与即付年金（annuity-due）" class="headerlink" title="8.普通年金（ordinary annuity）与即付年金（annuity due）"></a>8.普通年金（ordinary annuity）与即付年金（annuity due）</h2><p>年金（annuity）是在一定时间内的等间隔等值的持续现金流。一个人为了还清 年利率 10 % 的100 元的债务。两年中每年归还 57.62 元。那么他在这两年中每年归还的 57.62 元就是年金。</p>
<p>年金有两种结算方式，一种是普通年金（ordinary annuity），也就是每年年末支付。另一种是即付年金（annuity due），每年年初支付。普通年金每年的现金流（PMT）需要比即付年金多支付一年的利息。</p>
<h2 id="9-永续年金（Perpetuity）"><a href="#9-永续年金（Perpetuity）" class="headerlink" title="9.永续年金（Perpetuity）"></a>9.永续年金（Perpetuity）</h2><p>永续年金是是在无限时间内的等间隔等值的持续现金流。比如一个人买了一些股票，在理想情况下，这只股票将给他每年带来一定数额的收益，那么这支股票带来的收益就是永续年金（Perpetuity）。</p>
<p>永续年金的价值计算方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PV = PMT / (I/Y)</div></pre></td></tr></table></figure>
<h2 id="10-计算器的使用方式"><a href="#10-计算器的使用方式" class="headerlink" title="10.计算器的使用方式"></a>10.计算器的使用方式</h2><p>我们已经知道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FV = PV × (1 + I/Y) ^ N + PMT × &#123;[(1 - I/Y) ^ N] / (1 - I/Y)&#125;</div></pre></td></tr></table></figure>
<p>也就是说，PV、FV、I/Y、PMT、N 这五个参数组成了一个恒等式，只要知道其中的四个，就可以知道剩下的那个。下面举个例子通过计算器求 N：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个人欠了 100 元的债务，年利率 10 %。如果这个人选择分期付款，每年归还 57.62 元。请问几年还清？</div></pre></td></tr></table></figure>
<p>下面是输入的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">100 [PV]</div><div class="line">10 [I/Y]</div><div class="line">0 [FV]</div><div class="line">57.62 [+|-] [PMT]</div><div class="line">[CPT] [N]</div></pre></td></tr></table></figure>
<p>计算结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">N = 2.00</div></pre></td></tr></table></figure>
<h2 id="11-净现值（NPV）计算"><a href="#11-净现值（NPV）计算" class="headerlink" title="11.净现值（NPV）计算"></a>11.净现值（NPV）计算</h2><p>对于非恒定现金流（即每期的现金流的数量是不等的），可以采用净现值（NPV）计算，计算出该现金流折算成当前价值的数额：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个现金流的 PMT 为：-1000, 500, 0, 4000，3500, 2000，求净现值。</div></pre></td></tr></table></figure>
<p>则计算器输入的顺序为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[CF] [2nd] [CLR WORK]</div><div class="line">0 [ENTER]</div><div class="line">[↓] 1000 [+|-] [ENTER]</div><div class="line">[↓] [↓] 500 [+|-] [ENTER]</div><div class="line">[↓] [↓] 0  [ENTER]</div><div class="line">[↓] [↓] 4000 [ENTER]</div><div class="line">[↓] [↓] 3500 [ENTER]</div><div class="line">[↓] [↓] 2000 [ENTER]</div><div class="line">[NPV] 10 [ENTER]</div><div class="line">[↓] [CPT]</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NPV = 4711.91226</div></pre></td></tr></table></figure>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TVM/">TVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/零基础入门学习CFA/">零基础入门学习CFA</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-AndroidStudio安装教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/24/AndroidStudio安装教程/">AndroidStudio安装教程</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/09/24/AndroidStudio安装教程/" class="article-date">
  <time datetime="2017-09-24T10:38:00.000Z" itemprop="datePublished">2017-09-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-下载-Android-Studio-安装包"><a href="#1-下载-Android-Studio-安装包" class="headerlink" title="1.下载 Android Studio 安装包"></a>1.下载 Android Studio 安装包</h2><p>下载地址：<a href="http://www.android-studio.org/" target="_blank" rel="external">http://www.android-studio.org/</a></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240001.jpg" alt=""></p>
<h2 id="2-安装-Android-Studio"><a href="#2-安装-Android-Studio" class="headerlink" title="2.安装 Android Studio"></a>2.安装 Android Studio</h2><h3 id="2-1-打开安装程序"><a href="#2-1-打开安装程序" class="headerlink" title="2.1.打开安装程序"></a>2.1.打开安装程序</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240002.jpg" alt=""></p>
<h3 id="2-2-选择安装内容"><a href="#2-2-选择安装内容" class="headerlink" title="2.2.选择安装内容"></a>2.2.选择安装内容</h3><p>进入到选择安装内容界面，除了 <strong>Android Studio</strong> 之外，我们还需要安装 <strong>Android SDK</strong> 和 <strong>Android Virtual Device</strong>。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240003.jpg" alt=""></p>
<h3 id="2-3-选择-Android-Studio-和-SDK-的安装位置"><a href="#2-3-选择-Android-Studio-和-SDK-的安装位置" class="headerlink" title="2.3.选择 Android Studio 和 SDK 的安装位置"></a>2.3.选择 Android Studio 和 SDK 的安装位置</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240004.jpg" alt=""> </p>
<h3 id="2-4-开始安装"><a href="#2-4-开始安装" class="headerlink" title="2.4.开始安装"></a>2.4.开始安装</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240005.jpg" alt=""></p>
<h3 id="2-5-安装完成"><a href="#2-5-安装完成" class="headerlink" title="2.5.安装完成"></a>2.5.安装完成</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240007.jpg" alt=""></p>
<h2 id="3-基本配置"><a href="#3-基本配置" class="headerlink" title="3.基本配置"></a>3.基本配置</h2><h3 id="3-1-设置-SDK-路径"><a href="#3-1-设置-SDK-路径" class="headerlink" title="3.1. 设置 SDK 路径"></a>3.1. 设置 SDK 路径</h3><p>打开 <strong>Android Studio</strong>，会弹出设置 <strong>SDK</strong> 路径的对话框。选择刚才安装的 <strong>SDK</strong> 路径。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240011.jpg" alt=""></p>
<p>如果没有弹出或者路径设置错误，也可以自己在【项目结构】里面自行设定和修改。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240012.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240014.jpg" alt=""></p>
<h3 id="3-2-新建项目"><a href="#3-2-新建项目" class="headerlink" title="3.2.新建项目"></a>3.2.新建项目</h3><p>【文件】→【新建】→【新项目】</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240015.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240016.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240017.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240018.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240019.jpg" alt=""></p>
<h3 id="3-3-配置-AVD"><a href="#3-3-配置-AVD" class="headerlink" title="3.3.配置 AVD"></a>3.3.配置 AVD</h3><p>运行项目，弹出建立安卓虚拟机对话框。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240020.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240021.jpg" alt=""></p>
<p>建立安卓虚拟机。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240022.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240023.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240024.jpg" alt=""></p>
<p>用新建的安卓虚拟机运行程序。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240025.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201709240026.jpg" alt=""></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-TCP报文头结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/18/TCP报文头结构/">TCP报文头结构</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/18/TCP报文头结构/" class="article-date">
  <time datetime="2017-08-17T18:16:16.000Z" itemprop="datePublished">2017-08-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-TCP-报文头结构"><a href="#1-TCP-报文头结构" class="headerlink" title="1.TCP 报文头结构"></a>1.TCP 报文头结构</h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708240001.jpg" alt=""></p>
<h2 id="2-报文头各个部分说明"><a href="#2-报文头各个部分说明" class="headerlink" title="2.报文头各个部分说明"></a>2.报文头各个部分说明</h2><h3 id="2-1-Source-Port和Destination-Port"><a href="#2-1-Source-Port和Destination-Port" class="headerlink" title="2.1.Source Port和Destination Port:"></a>2.1.Source Port和Destination Port:</h3><p>分别占用16位，表示源端口号和目的端口号;用于区别主机中的不同进程， 而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一 的确定一个TCP连接;</p>
<h3 id="2-2-Sequence-Number"><a href="#2-2-Sequence-Number" class="headerlink" title="2.2.Sequence Number:"></a>2.2.Sequence Number:</h3><p>用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据 字节在数据流中的序号;主要用来解决网络报乱序的问题;</p>
<h3 id="2-3-Acknowledgment-Number"><a href="#2-3-Acknowledgment-Number" class="headerlink" title="2.3.Acknowledgment Number:"></a>2.3.Acknowledgment Number:</h3><p>32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应 当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字 段才有效。主要用来解决不丢包的问题;</p>
<h3 id="2-4-Offset"><a href="#2-4-Offset" class="headerlink" title="2.4.Offset:"></a>2.4.Offset:</h3><p>给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit(最多能 表示15个32bit的的字，即4*15=60个字节的首部长度)，因此TCP最多有60字节的首部。然而，没有任选字段， 正常的长度是20字节;</p>
<h3 id="2-5-TCP-Flags"><a href="#2-5-TCP-Flags" class="headerlink" title="2.5.TCP Flags:"></a>2.5.TCP Flags:</h3><p>TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次 为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：</p>
<h3 id="2-6-URG："><a href="#2-6-URG：" class="headerlink" title="2.6.URG："></a>2.6.URG：</h3><p>此标志表示TCP包的紧急指针域(后面马上就要说到)有效，用来保证TCP连接不被中断，并且督促 中间层设备要尽快处理这些数据;</p>
<h3 id="2-7-ACK："><a href="#2-7-ACK：" class="headerlink" title="2.7.ACK："></a>2.7.ACK：</h3><p>此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中;有两个取值：0和1， 为1的时候表示应答域有效，反之为0;</p>
<h3 id="2-8-PSH："><a href="#2-8-PSH：" class="headerlink" title="2.8.PSH："></a>2.8.PSH：</h3><p>这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序， 而不是在缓冲区中排队;</p>
<h3 id="2-9-RST："><a href="#2-9-RST：" class="headerlink" title="2.9.RST："></a>2.9.RST：</h3><p>这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包;</p>
<h3 id="3-0-SYN："><a href="#3-0-SYN：" class="headerlink" title="3.0.SYN："></a>3.0.SYN：</h3><p>表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1， ACK=0;连接被响应的时候，SYN=1，ACK=1;这个标志的数据包经常被用来进行端口扫描。扫描者发送 一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口;但是由于这 种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全 的主机将会强制要求一个连接严格的进行TCP的三次握手;</p>
<h3 id="3-1-FIN："><a href="#3-1-FIN：" class="headerlink" title="3.1.FIN："></a>3.1.FIN：</h3><p>表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志 位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</p>
<h3 id="3-2-Window"><a href="#3-2-Window" class="headerlink" title="3.2.Window:"></a>3.2.Window:</h3><p>窗口大小，也就是有名的滑动窗口。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-蓝牙协议入门（四）应用层协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/08/蓝牙协议入门（四）应用层协议/">蓝牙协议入门（四）应用层协议</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/08/蓝牙协议入门（四）应用层协议/" class="article-date">
  <time datetime="2017-08-08T02:10:47.000Z" itemprop="datePublished">2017-08-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-irOBEX-红外对象交互协议"><a href="#1-irOBEX-红外对象交互协议" class="headerlink" title="1.irOBEX 红外对象交互协议"></a>1.irOBEX 红外对象交互协议</h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030001.png" alt=""></p>
<p><strong>irOBEX</strong>  红外对象交互协议，简称 <strong>OBEX</strong>，使高层协议同时运作在蓝牙和红外的无线链路之上。主要操作指令包括：</p>
<ul>
<li>连接操作</li>
<li>断开操作</li>
<li>Put 操作</li>
<li>Get 操作</li>
</ul>
<h3 id="1-1-连接操作"><a href="#1-1-连接操作" class="headerlink" title="1.1.连接操作"></a>1.1.连接操作</h3><p>连接操作的操作码为： 0x80。</p>
<table>
<thead>
<tr>
<th>字节0</th>
<th>字节1、2</th>
<th>字节3</th>
<th>字节4</th>
<th>字节5、6</th>
<th>字节7～n</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x80</td>
<td>连接请求分组长度</td>
<td>OBEX版本号</td>
<td>标志</td>
<td>客户端可接收最大的OBEX分组长度</td>
<td>可选头</td>
</tr>
</tbody>
</table>
<p>下面是一个连接操作的示例：</p>
<table>
<thead>
<tr>
<th>字节0</th>
<th>字节1、2</th>
<th>字节3</th>
<th>字节4</th>
<th>字节5、6</th>
<th>字节7～n</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x80 Connect命令</td>
<td>7</td>
<td>0x10</td>
<td>flags</td>
<td>65534</td>
<td>可选头</td>
</tr>
</tbody>
</table>
<h3 id="1-2-断开操作"><a href="#1-2-断开操作" class="headerlink" title="1.2.断开操作"></a>1.2.断开操作</h3><p>断开操作的操作码为：0x81。</p>
<h3 id="1-3-Put-操作"><a href="#1-3-Put-操作" class="headerlink" title="1.3.Put 操作"></a>1.3.Put 操作</h3><p>Put 操作的操作码为：0x02。</p>
<h3 id="1-4-Get-操作"><a href="#1-4-Get-操作" class="headerlink" title="1.4.Get 操作"></a>1.4.Get 操作</h3><p>Get 操作的操作码为：0x03。</p>
<h2 id="2-音频与电话控制协议"><a href="#2-音频与电话控制协议" class="headerlink" title="2.音频与电话控制协议"></a>2.音频与电话控制协议</h2><h3 id="2-1-协议架构"><a href="#2-1-协议架构" class="headerlink" title="2.1.协议架构"></a>2.1.协议架构</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030002.png" alt=""></p>
<p>蓝牙音频如上图协议栈所示：音频通过基带传输同步面向连接分组实现，没有以规范的形式给出，不是协议栈的一部分。<br><strong>TCS_Binary</strong> 是一种基于分组电话控制二进制编码指令集，位于 <strong>L2CAP</strong> 之上。实现蓝牙无绳电话、对讲机功能。<br><strong>RFCOMM</strong> 用于 <strong>AT</strong> 指令，拨号上网、蓝牙耳机、耳麦、传真通过 <strong>AT</strong> 发送指令控制。</p>
<h3 id="2-2-音频部分"><a href="#2-2-音频部分" class="headerlink" title="2.2.音频部分"></a>2.2.音频部分</h3><p><strong>64kbps</strong> 电信级语言质量音频流<br>​    <strong>CVSD  continuous variable slope delta</strong> 连续可变斜率增量。<br>​    <strong>PCM  pulse code modulation</strong> 。<br>​    <strong>PCM</strong> 存在斜率效应。<strong>CVSD</strong> 使用音节压缩算法，编码步长根据信号斜率变化自动调整，是现在比较好的编码方案，提高语言的抗干扰能力。</p>
<h3 id="2-3-电话控制部分"><a href="#2-3-电话控制部分" class="headerlink" title="2.3.电话控制部分"></a>2.3.电话控制部分</h3><p><strong>TCS-Binary</strong> 电话控制部分。</p>
<ul>
<li><p>电话呼叫</p>
<p>​呼叫控制、呼叫建立、呼叫拆除；</p>
</li>
<li><p>组管理</p>
<p>​访问权限请求、分布式配置、快速内部成员访问。</p>
</li>
</ul>
<h2 id="3-网络封装协议-BNEP"><a href="#3-网络封装协议-BNEP" class="headerlink" title="3.网络封装协议  BNEP"></a>3.网络封装协议  BNEP</h2><p><strong>BNEP</strong>（<strong>Bluetooth Network Encapsulation Protocol</strong>） 网络封装协议。为了使集成蓝牙技术的电脑、电话、<strong>PDA</strong>、家用电器等网络设备交换信息，需要在网络层统一数据分组。网络封装协议将来自不同网络的数据分组重新封装，通过 <strong>L2CAP</strong> 进行传输。<strong>BNEP</strong> 支持 <strong>Ipv4、Ipv6、IPX</strong> 。</p>
<h2 id="4-音视频分发协议AVDTP"><a href="#4-音视频分发协议AVDTP" class="headerlink" title="4.音视频分发协议AVDTP"></a>4.音视频分发协议AVDTP</h2><p><strong>AVDTP （Audio/Video Distribution Transport Protocol）</strong>音视频分发传输协议。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030004.png" alt=""></p>
<p><strong>AVDTP</strong> 信令列表:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信令标识符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVDTP_DISCOVER</td>
<td>0x01</td>
<td>发现设备中的流端点</td>
</tr>
<tr>
<td>AVDTP_GET_CAPABILITIES</td>
<td>0x02</td>
<td>获得流端点的信息能力</td>
</tr>
<tr>
<td>AVDTP_SET_CONFIGURATION</td>
<td>0x03</td>
<td>对SEP进行配置</td>
</tr>
<tr>
<td>AVDTP_GET_CONFIGURATION</td>
<td>0x04</td>
<td>获取SEP当前配置</td>
</tr>
<tr>
<td>AVDTP_RECONFIGURE</td>
<td>0x05</td>
<td>对SEP重新配置</td>
</tr>
<tr>
<td>AVDTP_OPEN</td>
<td>0x06</td>
<td>成功的配置SEP后，打开流</td>
</tr>
<tr>
<td>AVDTP_START</td>
<td>0x07</td>
<td>流被打开：用于开始形成流；流暂停时：用于重新形成流。</td>
</tr>
<tr>
<td>AVDTP_CLOSE</td>
<td>0x08</td>
<td>对SEP关闭</td>
</tr>
<tr>
<td>AVDTP_SUSPEND</td>
<td>0x09</td>
<td>请求SEP暂停</td>
</tr>
<tr>
<td>AVDTP_SECURITY_CONTROL</td>
<td>0x0A</td>
<td>设置设备内容保护、或者请求设备状况信息</td>
</tr>
<tr>
<td>AVDTP_ABORT</td>
<td>0x0B</td>
<td>中断正在建立或者传输的过程</td>
</tr>
<tr>
<td>AVDTP_GET_ALL_CAPABILITIES</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AVDTP_DELAYREPORT</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="5-音视频控制传输协议AVCTP"><a href="#5-音视频控制传输协议AVCTP" class="headerlink" title="5.音视频控制传输协议AVCTP"></a>5.<strong>音视频控制传输协议AVCTP</strong></h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708030003.png" alt=""></p>
<p><strong>AVCTP</strong> 可以使音视频设备同时支持多个应用框架，每个应用框架定义了各自相应的消息格式与应用规则。</p>
<h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6.参考链接"></a>6.参考链接</h2><p> <a href="http://blog.csdn.net/xubin341719/article/details/38335533" target="_blank" rel="external">蓝牙核心技术概述（五）：蓝牙协议规范（irOBEX、BNEP、AVDTP、AVCTP）</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/蓝牙/">蓝牙</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-Redis常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/01/Redis常用命令/">Redis常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/08/01/Redis常用命令/" class="article-date">
  <time datetime="2017-08-01T08:12:47.000Z" itemprop="datePublished">2017-08-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h2><h3 id="1-1-SET-命令"><a href="#1-1-SET-命令" class="headerlink" title="1.1. SET 命令"></a>1.1. SET 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080001.png" alt=""></p>
<h3 id="1-2-GET-命令"><a href="#1-2-GET-命令" class="headerlink" title="1.2. GET 命令"></a>1.2. GET 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080002.png" alt=""></p>
<h3 id="1-3-GETSET-命令"><a href="#1-3-GETSET-命令" class="headerlink" title="1.3. GETSET 命令"></a>1.3. GETSET 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080003.png" alt=""></p>
<h3 id="1-4-INCR-自增命令"><a href="#1-4-INCR-自增命令" class="headerlink" title="1.4. INCR 自增命令"></a>1.4. INCR 自增命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080004.png" alt=""></p>
<h2 id="2-有序集合（Sorted-Set）"><a href="#2-有序集合（Sorted-Set）" class="headerlink" title="2.有序集合（Sorted Set）"></a>2.有序集合（Sorted Set）</h2><h3 id="2-1-ZADD-命令"><a href="#2-1-ZADD-命令" class="headerlink" title="2.1. ZADD 命令"></a>2.1. ZADD 命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080005.png" alt=""></p>
<h3 id="2-2-ZCARD-数量统计命令"><a href="#2-2-ZCARD-数量统计命令" class="headerlink" title="2.2. ZCARD 数量统计命令"></a>2.2. ZCARD 数量统计命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080006.png" alt=""></p>
<h3 id="2-3-ZCOUNT-查找指定区间成员数命令"><a href="#2-3-ZCOUNT-查找指定区间成员数命令" class="headerlink" title="2.3. ZCOUNT 查找指定区间成员数命令"></a>2.3. ZCOUNT 查找指定区间成员数命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080007.png" alt=""></p>
<h3 id="2-4-ZRANK-返回查找值排名命令"><a href="#2-4-ZRANK-返回查找值排名命令" class="headerlink" title="2.4. ZRANK 返回查找值排名命令"></a>2.4. ZRANK 返回查找值排名命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080008.png" alt=""></p>
<h3 id="2-5-ZREM-移除元素命令"><a href="#2-5-ZREM-移除元素命令" class="headerlink" title="2.5. ZREM 移除元素命令"></a>2.5. ZREM 移除元素命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080009.png" alt=""></p>
<h3 id="2-6-ZUNIONSTORE-并集命令"><a href="#2-6-ZUNIONSTORE-并集命令" class="headerlink" title="2.6. ZUNIONSTORE 并集命令"></a>2.6. ZUNIONSTORE 并集命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080010.png" alt=""></p>
<h3 id="2-7-ZINTERSTORE-交集命令"><a href="#2-7-ZINTERSTORE-交集命令" class="headerlink" title="2.7. ZINTERSTORE 交集命令"></a>2.7. ZINTERSTORE 交集命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080011.png" alt=""></p>
<h3 id="2-8-ZRANGE-范围显示指令"><a href="#2-8-ZRANGE-范围显示指令" class="headerlink" title="2.8. ZRANGE 范围显示指令"></a>2.8. ZRANGE 范围显示指令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080011.png" alt=""></p>
<h2 id="3-哈希（HashSet）"><a href="#3-哈希（HashSet）" class="headerlink" title="3. 哈希（HashSet）"></a>3. 哈希（HashSet）</h2><h3 id="3-1-HSET-插入指令"><a href="#3-1-HSET-插入指令" class="headerlink" title="3.1. HSET 插入指令"></a>3.1. HSET 插入指令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080012.png" alt=""></p>
<h3 id="3-2-HGET-读取指令"><a href="#3-2-HGET-读取指令" class="headerlink" title="3.2. HGET 读取指令"></a>3.2. HGET 读取指令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080013.png" alt=""></p>
<h3 id="3-3-HGETALL-读取全部"><a href="#3-3-HGETALL-读取全部" class="headerlink" title="3.3. HGETALL 读取全部"></a>3.3. HGETALL 读取全部</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080014.png" alt=""></p>
<h3 id="3-4-HSETNX-如果不存在则赋值"><a href="#3-4-HSETNX-如果不存在则赋值" class="headerlink" title="3.4. HSETNX 如果不存在则赋值"></a>3.4. HSETNX 如果不存在则赋值</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080015.png" alt=""></p>
<h3 id="3-5-HDEL-删除"><a href="#3-5-HDEL-删除" class="headerlink" title="3.5. HDEL 删除"></a>3.5. HDEL 删除</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080016.png" alt=""></p>
<h2 id="4-列表（List）"><a href="#4-列表（List）" class="headerlink" title="4.列表（List）"></a>4.列表（List）</h2><h3 id="4-1-PUSH（插入元素，分为左-LPUSH-和右-RPUSH）"><a href="#4-1-PUSH（插入元素，分为左-LPUSH-和右-RPUSH）" class="headerlink" title="4.1. PUSH（插入元素，分为左 LPUSH 和右 RPUSH）"></a>4.1. PUSH（插入元素，分为左 LPUSH 和右 RPUSH）</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080017.png" alt=""></p>
<h3 id="4-2-LRANGE-输出某一段元素"><a href="#4-2-LRANGE-输出某一段元素" class="headerlink" title="4.2. LRANGE 输出某一段元素"></a>4.2. LRANGE 输出某一段元素</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080018.png" alt=""></p>
<h3 id="4-3-POP（分为-LPOP-和-RPOP）"><a href="#4-3-POP（分为-LPOP-和-RPOP）" class="headerlink" title="4.3. POP（分为 LPOP 和 RPOP）"></a>4.3. POP（分为 LPOP 和 RPOP）</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080019.png" alt=""></p>
<h3 id="4-4-LLEN-输出列表长度"><a href="#4-4-LLEN-输出列表长度" class="headerlink" title="4.4. LLEN 输出列表长度"></a>4.4. LLEN 输出列表长度</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080020.png" alt=""></p>
<h3 id="4-5-LINDEX-输出某位置元素"><a href="#4-5-LINDEX-输出某位置元素" class="headerlink" title="4.5. LINDEX 输出某位置元素"></a>4.5. LINDEX 输出某位置元素</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080021.png" alt=""></p>
<h2 id="5-集合"><a href="#5-集合" class="headerlink" title="5.集合"></a>5.集合</h2><h3 id="5-1-SADD-插入命令"><a href="#5-1-SADD-插入命令" class="headerlink" title="5.1. SADD 插入命令"></a>5.1. SADD 插入命令</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080022.png" alt=""></p>
<h3 id="5-2-SCARD-统计个数命令"><a href="#5-2-SCARD-统计个数命令" class="headerlink" title="5.2. SCARD 统计个数命令"></a>5.2. SCARD 统计个数命令</h3><p>​              <img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080023.png" alt=""></p>
<h3 id="5-3-SDIFFSTORE-差集并存储"><a href="#5-3-SDIFFSTORE-差集并存储" class="headerlink" title="5.3. SDIFFSTORE 差集并存储"></a>5.3. SDIFFSTORE 差集并存储</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080024.png" alt=""></p>
<h3 id="5-4-SUNION-并集（SUNIONSTORE-则存储）"><a href="#5-4-SUNION-并集（SUNIONSTORE-则存储）" class="headerlink" title="5.4. SUNION 并集（SUNIONSTORE 则存储）"></a>5.4. SUNION 并集（SUNIONSTORE 则存储）</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080025.png" alt=""></p>
<h3 id="5-5-SINTER-交集"><a href="#5-5-SINTER-交集" class="headerlink" title="5.5. SINTER 交集"></a>5.5. SINTER 交集</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080026.png" alt=""></p>
<h3 id="5-6-SPOP-随机弹出"><a href="#5-6-SPOP-随机弹出" class="headerlink" title="5.6. SPOP 随机弹出"></a>5.6. SPOP 随机弹出</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080027.png" alt=""></p>
<h3 id="5-7-SMEMBERS-显示所有元素"><a href="#5-7-SMEMBERS-显示所有元素" class="headerlink" title="5.7. SMEMBERS 显示所有元素"></a>5.7. SMEMBERS 显示所有元素</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201708080028.png" alt=""></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-java基础之垃圾回收器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/25/java基础之垃圾回收器/">Java基础之垃圾回收器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/07/25/java基础之垃圾回收器/" class="article-date">
  <time datetime="2017-07-25T10:38:00.000Z" itemprop="datePublished">2017-07-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h2><p><strong>Serial</strong> 收集器是单线程垃圾回收器，它仅能使用单个线程去进行垃圾回收的工作，而且在进行垃圾回收时需要 <strong>“Stop the World”</strong>。也就是说，在它工作的同时，其他线程必须暂停运行。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260001.png" alt=""></p>
<h2 id="2-Serial-Old-收集器"><a href="#2-Serial-Old-收集器" class="headerlink" title="2. Serial Old 收集器"></a>2. Serial Old 收集器</h2><p><strong>Serial</strong> 收集器的老年代版本。一种用途是在 <strong>JDK 1.5</strong> 以及之前的版本中与<strong>Parallel Scavenge</strong> 收集器搭配使用，另一种用途就是作为<strong>CMS</strong> 收集器的后备预案，在并发收集发生<strong>Concurrent Mode Failure</strong> 时使用。 </p>
<h2 id="3-ParNew-收集器"><a href="#3-ParNew-收集器" class="headerlink" title="3. ParNew 收集器"></a>3. ParNew 收集器</h2><p><strong>ParNew</strong> 收集器是 <strong>Serial</strong> 收集器的多线程版本。因为功能强大的老年代收集器 <strong>CMS</strong> 收集器无法与 <strong>Parallel Scavenge</strong> 收集器配合工作，因此 <strong>CMS</strong> 收集器常与 <strong>ParNew</strong> 收集器配合使用。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260002.png" alt=""></p>
<h2 id="4-Parallel-Scavenge-收集器"><a href="#4-Parallel-Scavenge-收集器" class="headerlink" title="4. Parallel Scavenge 收集器"></a>4. Parallel Scavenge 收集器</h2><p><strong>Parallel Scavenge</strong> 收集器的特点是它的关注点与其他收集器不同，<strong>CMS</strong> 等收集器的关注点<br>是尽可能地缩短垃圾收集时用户线程的停顿时间，而<strong>Parallel Scavenge</strong> 收集器的目标则是达到<br>一个可控制的吞吐量。 </p>
<h2 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h2><p><strong>Parallel Old</strong> 是 <strong>Parallel Scavenge</strong> 收集器的老年代版本，使用多线程和“标记-整理”算法。<br>这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 <strong>Parallel Scavenge</strong> 收集器一直<br>处于比较尴尬的状态。 原因是，如果新生代选择了<strong>Parallel Scavenge</strong> 收集器，老年代除了<br><strong>Serial Old</strong> 收集器外别无选择。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260003.png" alt=""></p>
<h2 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h2><p><strong>CMS（Concurrent Mark Sweep）</strong>收集器是一种以获取最短回收停顿时间为目标的收集器。   </p>
<p>其工作步骤分为以下四步：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep） </li>
</ul>
<p>其中，初始标记、 重新标记这两个步骤仍然需要“Stop The World”。 初始标记仅仅只是标记一下<strong>GC Roots</strong> 能直接关联到的对象，速度很快，并发标记阶段就是进行 <strong>GC RootsTracing</strong> 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260004.png" alt=""></p>
<h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h2><p><strong>G1</strong> 是一款面向服务端应用的垃圾收集器。 <strong>HotSpot</strong> 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 <strong>JDK 1.5</strong> 中发布的 <strong>CMS</strong> 收集器。 与 <strong>CMS</strong> 收集器相比，<strong>G1</strong>具备如下特点。 </p>
<ul>
<li>空间整合：与 <strong>CMS</strong> 的“标记—清理”算法不同，<strong>G1</strong> 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个<strong>Region</strong>之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 <strong>G1</strong> 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 <strong>GC</strong>。</li>
<li>可预测的停顿：这是 <strong>G1</strong> 相对于 <strong>CMS</strong> 的另一大优势，降低停顿时间是 <strong>G1</strong> 和 <strong>CMS</strong> 共同的关注点，但 <strong>G1</strong> 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 <strong>Java（RTSJ）</strong>的垃圾收集器的特征了。</li>
</ul>
<p>值得一提的是，在 <strong>G1</strong> 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 <strong>G1</strong> 不再是这样。 使用 <strong>G1</strong> 收集器时，<strong>Java</strong> 堆的内存布局就与其他收集器有很大差别，它将整个 <strong>Java</strong> 堆划分为多个大小相等的独立区域（<strong>Region</strong>），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 <strong>Region</strong>（不需要连续）的集合。 </p>
<p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation） </li>
</ul>
<p>前三个阶段与 <strong>CMS</strong> 收集器相似，最后在筛选回收阶段首先对各个<strong>Region</strong> 的回收价值和成本进行排序，<br>根据用户所期望的 <strong>GC</strong> 停顿时间来制定回收计划。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707260005.png" alt=""></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/垃圾回收/">垃圾回收</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-蓝牙协议入门（三）中介层协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/06/蓝牙协议入门（三）中介层协议/">蓝牙协议入门（三）中介层协议</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/07/06/蓝牙协议入门（三）中介层协议/" class="article-date">
  <time datetime="2017-07-05T17:38:37.000Z" itemprop="datePublished">2017-07-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-主机控制接口协议-HCI"><a href="#1-主机控制接口协议-HCI" class="headerlink" title="1.主机控制接口协议 HCI"></a>1.主机控制接口协议 HCI</h2><p>常用蓝牙控制器接口数据分组分为三类，分别为：</p>
<ul>
<li>指令分组（0x01）</li>
<li>事件分组（0x04）</li>
<li>数据分组（ACL：0x02，SCO：0x03）</li>
</ul>
<p>全部分组类型列举如下：</p>
<table>
<thead>
<tr>
<th>HCI 分组类型</th>
<th>RS232分组指示器</th>
</tr>
</thead>
<tbody>
<tr>
<td>HCI指令分组</td>
<td>0x01</td>
</tr>
<tr>
<td>HCI ACL数据分组</td>
<td>0x02</td>
</tr>
<tr>
<td>HCI SCO数据分组</td>
<td>0x03</td>
</tr>
<tr>
<td>HCI事件分组</td>
<td>0x04</td>
</tr>
<tr>
<td>HCI错误消息分组</td>
<td>0x05</td>
</tr>
<tr>
<td>HCI协商分组</td>
<td>0x06</td>
</tr>
</tbody>
</table>
<h3 id="1-1-指令分组"><a href="#1-1-指令分组" class="headerlink" title="1.1.指令分组"></a>1.1.指令分组</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280001.png" alt=""></p>
<p>如：<strong>Accpet Connection Request</strong></p>
<ul>
<li><strong>Opcode</strong> 为：<strong>0x0409</strong></li>
<li>参数长度为: <strong>07</strong> <ul>
<li>参数中蓝牙地址为：<strong>00:0d:fd:5f:16:9f</strong></li>
</ul>
</li>
<li>角色为：从设备  <strong>0x01</strong></li>
</ul>
<p>则大端数据模式指令为：<strong>09 04 07 9f 16 5f fd 0d 00 01</strong></p>
<h3 id="1-2-事件分组"><a href="#1-2-事件分组" class="headerlink" title="1.2.事件分组"></a>1.2.事件分组</h3><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280002.png" alt=""></p>
<p>如：<strong>Accpet Connection Request</strong></p>
<ul>
<li><strong>Opcode :0x0409</strong></li>
<li>状态： <strong>0x00</strong></li>
<li>总长度： <strong>4</strong> 字节</li>
<li>命令状态：<strong>0x0f</strong></li>
</ul>
<p>则分组为： <strong>04 0f 04 00 01 09 04</strong></p>
<h3 id="1-3-数据分组"><a href="#1-3-数据分组" class="headerlink" title="1.3.数据分组"></a>1.3.数据分组</h3><p><strong>ACL</strong> 数据分组（注：<strong>PB =  Packet_Boundary</strong> ； <strong>BC =  Broadcast Flag</strong>）</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280003.png" alt=""></p>
<p><strong>SCO</strong> 数据分组</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280004.png" alt=""></p>
<h2 id="2-逻辑链路控制与适配协议-L2CAP"><a href="#2-逻辑链路控制与适配协议-L2CAP" class="headerlink" title="2.逻辑链路控制与适配协议  L2CAP"></a>2.逻辑链路控制与适配协议  L2CAP</h2><p><strong>L2CAP</strong> 位于基带之上，将基带的数据分组转换为便于高层应用的数据分组格式，并提供协议复用和服务质量交换等功能。<strong>L2CAP</strong> 只支持 <strong>ACL</strong> 数据传输，不支持 <strong>SCO</strong> 数据。<strong>L2CAP</strong> 本身不提供加强信道可靠性和保证数据完整性的机制，其信道的可靠性依靠基带提供。</p>
<p><strong>L2CAP</strong> 主要实现以下功能：</p>
<ol>
<li><strong>协议复用</strong>：底层传输协议没有提供对高层协议的复用机制，因而 L2CAP 支持高层协议复用，L2CAP 层可以区分其上的 SDP、RFCOMM、TCS 等。</li>
<li><strong>分段重组</strong>：L2CAP层帮助实现基带的短 PDU 和高层的长 PDU 相互传输，L2CAP 本身不完成任何 PDU 的分段重组，具体的分段重组有低层和高层来完成。</li>
<li><strong>服务质量 Qualityof Serivce 信息的交换</strong>：蓝牙建立连接的过程中，L2CAP允许交互蓝牙所期望的服务质量，建立完成后，通过监视资源的使用情况，来保证服务质量。</li>
<li><strong>组抽象</strong>：<strong>L2CAP</strong> 忽略地址组概念，他只关心数据。</li>
</ol>
<p><strong>L2CAP</strong> 信道有三种类型：</p>
<ul>
<li>面向连接信道：<strong>Connection-Oriented CO</strong>，用于两个设备之间的数据通信。</li>
<li>无连接信道：<strong>Connection-LessCL</strong>，用来向一组设备广播方式传输数据。<strong>CID</strong>为固定值：<strong>0x0002。</strong></li>
<li>信令信道：<strong>Signaling</strong>，用于创建 <strong>CO</strong> 通道，可以通过协商改变 <strong>CO</strong> 信道的特性。</li>
</ul>
<p>协议数据单元：</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280005.png" alt=""></p>
<h2 id="3-服务发现协议-SDP"><a href="#3-服务发现协议-SDP" class="headerlink" title="3.服务发现协议   SDP"></a>3.服务发现协议   SDP</h2><p>SDP两种服务发现模式：            </p>
<ul>
<li>服务搜索：查询具有特定服务属性的服务；            </li>
<li>服务浏览：简单的浏览全部可用服务。</li>
</ul>
<p>其 <strong>PDU</strong> （协议数据单元）格式为：</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280006.png" alt=""></p>
<p>不同的 <strong>PDU ID</strong> 的意义为：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Parameter Descirption</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>Reserved</td>
<td>保留</td>
</tr>
<tr>
<td>0x01</td>
<td>SDP_ErrorResponse</td>
<td>错误响应</td>
</tr>
<tr>
<td>0x02</td>
<td>SDP_ServiceSearchRequest</td>
<td>服务搜索请求</td>
</tr>
<tr>
<td>0x03</td>
<td>SDP_ServiceSearchResponse</td>
<td>服务搜索响应</td>
</tr>
<tr>
<td>0x04</td>
<td>SDP_ServiceAttributeRequest</td>
<td>服务属性请求</td>
</tr>
<tr>
<td>0x05</td>
<td>SDP_ServiceAttributeResponse</td>
<td>服务属性响应</td>
</tr>
<tr>
<td>0x06</td>
<td>SDP_ServiceSearchAttributeRequest</td>
<td>服务搜索属性请求</td>
</tr>
<tr>
<td>0x07</td>
<td>SDP_ServiceSearchAttributeResponse</td>
<td>服务搜索属性响应</td>
</tr>
<tr>
<td>0x08-0xff</td>
<td>Reserved</td>
<td>保留</td>
</tr>
</tbody>
</table>
<h2 id="4-串口仿真协议-RFCOMM"><a href="#4-串口仿真协议-RFCOMM" class="headerlink" title="4.串口仿真协议   RFCOMM"></a>4.串口仿真协议   RFCOMM</h2><p><strong>RFCOMM</strong> 是为建立在串口之上的传统应用提供环境接口，使他们可以做比较少协议改动就可以在蓝牙无线通信无线链路上工作。多路串口仿真是 <strong>RFCOMM</strong> 的重要功能，通过多路复用器(<strong>multiplexer</strong>)，一条 <strong>L2CAP</strong> 链路可以同时 多个串行应用。</p>
<p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201707280007.png" alt=""></p>
<p><strong>RFCOMM</strong> 两个蓝牙设备之间可以支持多达60多路仿真串口。<strong>RFCOMM</strong> 帧类型如下：</p>
<table>
<thead>
<tr>
<th>SABM</th>
<th>异步平衡模式设置指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>UA</td>
<td>未加编号的确认响应</td>
</tr>
<tr>
<td>DM</td>
<td>断开连接模式响应</td>
</tr>
<tr>
<td>DISC</td>
<td>断开连接指令</td>
</tr>
<tr>
<td>UIH</td>
<td>带头校验的未编号信息命令和响应</td>
</tr>
</tbody>
</table>
<h2 id="X-参考连接"><a href="#X-参考连接" class="headerlink" title="X.参考连接"></a>X.参考连接</h2><p><a href="http://blog.csdn.net/xubin341719/article/details/38305331" target="_blank" rel="external">蓝牙核心技术概述（四）：蓝牙协议规范（HCI、L2CAP、SDP、RFOCMM）</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/蓝牙/">蓝牙</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-TCP的三次握手与四次挥手" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/TCP的三次握手与四次挥手/">TCP的三次握手与四次挥手</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/06/28/TCP的三次握手与四次挥手/" class="article-date">
  <time datetime="2017-06-28T09:49:08.000Z" itemprop="datePublished">2017-06-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-TCP-建立与断开流程"><a href="#1-TCP-建立与断开流程" class="headerlink" title="1.TCP 建立与断开流程"></a>1.TCP 建立与断开流程</h2><p><img src="https://raw.githubusercontent.com/JackSmithThu/MarkdownPhotos/master/201706280001.png" alt="figure"></p>
<h2 id="2-为什么是三次握手"><a href="#2-为什么是三次握手" class="headerlink" title="2.为什么是三次握手"></a>2.为什么是三次握手</h2><p><strong>如果两次握手</strong>，那么只要客户端发送请求，就会建立连接。在这种情况下，如果有请求在信道上发生滞留，服务端就会收到一个失效的报文端，并误以为是客户端新的请求。由于客户端并不会对服务端的响应进行应答，所以在这种情况下，服务端以为连接建立了，而客户端并没有发出连接请求，所以永远也不会想服务端发送数据。</p>
<p>所以，三次握手是保证双方能够就发送数据这一问题达成一致所需要的最小值。</p>
<h2 id="3-为什么是四次挥手"><a href="#3-为什么是四次挥手" class="headerlink" title="3.为什么是四次挥手"></a>3.为什么是四次挥手</h2><p>因为 <strong>TCP</strong> 是双工协议，当客户端没有想要发送的东西的时候，服务端可能还有想发送的东西。所以客户端只能单方面地承诺自己不再发送。而 <strong>TCP</strong> 真正的结束应该是服务端也承诺不再发送并得到应答才可以。</p>
<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4.参考链接"></a>4.参考链接</h2><p><a href="http://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="external">TCP的三次握手(建立连接）和四次挥手(关闭连接）</a></p>
<p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="external">TCP 为什么是三次握手，为什么不是两次或四次？</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Jack Smith&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>